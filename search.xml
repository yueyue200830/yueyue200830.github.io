<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新版Windows Terminal</title>
    <url>/2020/02/29/%E6%96%B0%E7%89%88Windows-Terminal/</url>
    <content><![CDATA[<p>微软在19年的时候宣布开发新的Windows Terminal，虽然这仅仅是一个终端，并非开发一个新的shell，但是新版整合了各种shell并且超级好看！！<br>这个终端的优点是可以打开各种不同的shell，比如<code>cmd</code>、<code>PowerShell</code>、<code>Azure</code>、<code>GitBash</code>等。</p>
<a id="more"></a>

<p>截图：</p>
<img src="/2020/02/29/%E6%96%B0%E7%89%88Windows-Terminal/terminal.png" class="" width="700" title="Terminal">

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>微软在<a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener">Github</a>上公开了代码，可以有两种方法安装，一个是用VS，还有就是直接应用商店下载</p>
<p>只是想玩一下的我当然应用商店下载啦，又方便又不容易又bug，就是更新慢点而已</p>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>在微软应用商店搜索<code>Windows Terminal</code>，可以找到以下内容，安装即可</p>
<img src="/2020/02/29/%E6%96%B0%E7%89%88Windows-Terminal/store.png" class="" width="700" title="Store">

<h1 id="使用与配置"><a href="#使用与配置" class="headerlink" title="使用与配置"></a>使用与配置</h1><p>安装好后可以直接打开，会发现emmm没有什么好看的，当然主要的大招是自己配置哈哈哈</p>
<p>找到下拉菜单，可以发现应该有cmd、PowserShell和Azure，选择<code>setting</code>，用文本编辑器打开，这是一个<code>json</code>的配置文件</p>
<h2 id="增加亚力克（Acrylic）效果"><a href="#增加亚力克（Acrylic）效果" class="headerlink" title="增加亚力克（Acrylic）效果"></a>增加亚力克（Acrylic）效果</h2><p>在每个shell的配置文件中添加：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"useAcrylic": true</span><br></pre></td></tr></table></figure>

<p>保存重新打开就可以看到之前本文的截图效果了（也就是毛玻璃），瞬间爱了呀！<br>然而鸡肋的cmd并没有因此有改进。。。只是界面影响心情所以喜欢了哈哈哈</p>
<h2 id="切换默认shell"><a href="#切换默认shell" class="headerlink" title="切换默认shell"></a>切换默认shell</h2><p>安装打开后默认应该是PowerShell，由于不用PowerShell，所以把它改成了cmd</p>
<p>找到<code>defaultProfile</code>，把它的内容改成你想到修改的shell对应的<code>guid</code></p>
<p>比如我的cmd配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make changes here to the cmd.exe profile</span></span><br><span class="line">    <span class="attr">"guid"</span>: <span class="string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"cmd"</span>,</span><br><span class="line">    <span class="attr">"commandline"</span>: <span class="string">"cmd.exe"</span>,</span><br><span class="line">    <span class="attr">"hidden"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"useAcrylic"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么defaultProfile就改为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"defaultProfile": "&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span><br></pre></td></tr></table></figure>

<h2 id="添加gitbash"><a href="#添加gitbash" class="headerlink" title="添加gitbash"></a>添加gitbash</h2><p>配置如下，复制进去基本就可以</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Git Bash</span></span><br><span class="line">    <span class="attr">"guid"</span>: <span class="string">"&#123;00000000-0000-0000-ba54-000000000002&#125;"</span>,</span><br><span class="line">    <span class="attr">"closeOnExit"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"colorScheme"</span> : <span class="string">"Campbell"</span>,</span><br><span class="line">    <span class="attr">"commandline"</span> : <span class="string">"\"%PROGRAMFILES%\\git\\usr\\bin\\bash.exe\" -i -l"</span>,</span><br><span class="line">    <span class="attr">"cursorColor"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">    <span class="attr">"cursorShape"</span> : <span class="string">"bar"</span>,</span><br><span class="line">    <span class="attr">"historySize"</span> : <span class="number">9001</span>,</span><br><span class="line">    <span class="attr">"icon"</span> : <span class="string">"%PROGRAMFILES%\\Git\\mingw64\\share\\git\\git-for-windows.ico"</span>,</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Git Bash"</span>,</span><br><span class="line">    <span class="attr">"snapOnInput"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"startingDirectory"</span> : <span class="string">"%USERPROFILE%"</span>,</span><br><span class="line">    <span class="attr">"useAcrylic"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于icon，我自己的是mitty的gitbash，所以有以上位置，但如果用的cmd的，icon应该位置不太一样，这里没有去搜过，如果跳不出来可以去搜索或者直接自己硬找一下</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>其实写这篇博文主要还是脑子一抽觉得new Windows Terminal真的好好看呀，但是其实并不怎么使用它。。。<br>毕竟习惯性打开cmd或者右键gitbash了</p>
<p>但是组合在一起其实使用起来还是比较方便的，并且比较好看的界面+好看的字体+支持windows表情还是很不错的。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Google Play Store一直「正在等待下载」的问题</title>
    <url>/2020/02/29/%E8%A7%A3%E5%86%B3Google-Play-Store%E4%B8%80%E7%9B%B4%E3%80%8C%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>大概月初开始，我的小米的Play Store就开始卡在<code>正在等待下载</code>，play store其它内容加载一切正常，其它网页加载也都正常，但是就是无法更新。。<br>卡了近一个月后终于想到网络搜索解决问题了。</p>
<a id="more"></a>

<ol>
<li>确保是软件问题，play store可加载其它内容，且没有程序卡在<code>正在下载</code></li>
<li>打开play store的应用信息，选择<code>清楚全部数据</code>，可能会出现提示，按确定清除数据<img src="/2020/02/29/%E8%A7%A3%E5%86%B3Google-Play-Store%E4%B8%80%E7%9B%B4%E3%80%8C%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98/play-store.jpg" class="" width="300" title="Play-store"></li>
<li>【小米手机/部分国内手机】打开<code>下载管理</code>（或类似名称），禁用迅雷加速下载<img src="/2020/02/29/%E8%A7%A3%E5%86%B3Google-Play-Store%E4%B8%80%E7%9B%B4%E3%80%8C%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98/xunlei.jpg" class="" width="300" title="Xunlei"></li>
<li>打开下载管理的应用信息，选择<code>清楚全部数据</code></li>
<li>重新打开play store，查看是否恢复正常</li>
</ol>
<p>完全不懂什么原理，个人猜测线程卡死死锁了？<br>据说play store的下载机制是通过手机自己的下载来下载的，所以可能出奇奇怪怪的问题。。</p>
<p>ps. play store绝对是一个神奇的软件，在我的三星出现了一个更迷的bug，无法自动更新play store，永远显示已经最新版，且确定过版本应该不是盗版。。。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo多终端同步及发布至Github</title>
    <url>/2020/02/24/Hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E5%8F%8A%E5%8F%91%E5%B8%83%E8%87%B3Github/</url>
    <content><![CDATA[<p>因为有两台电脑的关系，很多东西都需要同步，一般文件比较小的会用<code>Onedrive</code>，文件比较大的比如Hexo会选择用<code>GitHub</code>（主要贫穷的我只有5G的免费空间）。<br>相比于其它普通文件夹直接push就可以同步，这个就稍微麻烦一点，因为整个文件夹里有多个含有git的文件夹。<br>而在第一次直接把跟目录push上去以后，甚至遇到了这个网站<code>yueyue200830.github.io</code>的github全部被覆盖。<br>当时整个人内心都十分崩溃。。。</p>
<a id="more"></a>

<h1 id="解决方法之概念"><a href="#解决方法之概念" class="headerlink" title="解决方法之概念"></a>解决方法之概念</h1><p>首先，我们需要了解一下hexo是如何push到github上的</p>
<p>在根目录寻找一圈后，会发现有一个<code>.deploy_git</code>的文件夹，打开发现和github上面的文件完全一样。<br>没错了，hexo就是直接编译在这个文件夹生成文件，然后push到github上面。</p>
<p>然而，不要高兴太早，如果单纯的push为什么换电脑是覆盖而不是有任何的conflict信息呢？</p>
<p>在<code>.deploy_git</code>文件夹在打开<code>git bash</code>，输入<code>git remote -v</code>，发现竟然什么也没有？？？</p>
<p>介于自己完全不熟练<code>git</code>命令，打开了外部有同步的文件夹同样输入<code>git remote -v</code>，是会得到以下显示的</p>
<img src="/2020/02/24/Hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E5%8F%8A%E5%8F%91%E5%B8%83%E8%87%B3Github/gitbash1.png" class="" title="Screenshot1">

<p>虽然不清楚发生了什么（对不起，我就是一个git小白）。。但是可以知道我们git仓库没有github上面的信息<br>也就是每次hexo在deploy的时候，是直接把整个仓库替换上去的（好粗暴呀。。）</p>
<p>而再去看一下整个项目的github，发面默认的gitignore里把<code>.deploy_git</code>添加上了。<br>也就是说同步的时候根本没有任何之前发布的信息，所以当换了一台电脑的时候就会遇到如此崩溃的事情了。</p>
<h1 id="解决方法之实际操作"><a href="#解决方法之实际操作" class="headerlink" title="解决方法之实际操作"></a>解决方法之实际操作</h1><p>既然<code>.deploy_git</code>和项目各会同步在我的github上，那么与其取消ignore，不如在<code>.deploy_git</code>上添加远程仓库，每次更新前做一个同步。</p>
<p>在<code>.deploy_git</code>文件夹的终端下输入以下内容，让其连接到github仓库（注意在最后加上<code>.git</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/yueyue200830/yueyue200830.github.io.git</span><br></pre></td></tr></table></figure>

<p>这个时候，我们再输入<code>git remote -v</code>，可以看到有信息了</p>
<p>再把remote和本地的进行一次同步：（应该用pull也可以）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>这样，我们就在本地同步与github同步成功了，只需要再另一台电脑上也进行以下同步配置，之后每次换电脑的时候只需要两个文件夹各同步一下就可以啦。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>多终端</tag>
      </tags>
  </entry>
  <entry>
    <title>Github加速访问/防DNS污染</title>
    <url>/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/</url>
    <content><![CDATA[<p>在访问DNS有的时候会比较慢甚至无法打开，而我最近遇到的一个问题是DNS被污染，并且由于同时加载了境内和境外DNS，根本无法找到究竟是哪里受到了DNS污染。为此我搜了不少资料，最终得到了以下的解决方案，不过其实这个方法个人认为也是治标不治本。</p>
<p>解决方法就是本地设置<code>hosts</code>/<code>DNS</code>，强制直接让网站访问某个ip从而跳过寻找ip地址。</p>
<a id="more"></a>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>简单讲一下原理（应该其实会一点CS的都懂啦），可以跳过。</p>
<p>在访问网站时，由于我们输入的是域名（如<code>www.google.com</code>)，需要寻找它真实的ip地址再去访问。<br>那如何获取它的ip地址呢，这就是DNS和hosts的用处了。</p>
<p>电脑首先在本地的<code>hosts</code>中寻找域名对应的ip，比如<code>localhost</code>是直接对应<code>127.0.0.0</code>。<br>如果能在hosts中寻找到，那么就直接进行下一步去加载网页了<br>但往往hosts中没有太多的对应，于是就下一步采用<code>DNS</code>寻找ip。</p>
<p>相对于hosts在本地，DNS在无其他配置情况下是通过网络查找的，而在这个时候，可能会有人在查找的结果中动一些手脚，明明是<code>11.11.11.11</code>的ip，却让它返回<code>22.22.22.22</code>。<br>那这样，这个网址就无法加载了。</p>
<p>此外，当Github访问速度过慢也可能是在DNS查找时比较慢，又或者因为这种大的网站一般有多个ip，我们访问了最远的ip，那么就会很慢了。</p>
<p>因此，通过修改hosts直接强制域名对应ip，使得DNS查找这个步骤可以省略，且访问速度较快的一个ip。</p>
<h1 id="一、获取需要解析的地址"><a href="#一、获取需要解析的地址" class="headerlink" title="一、获取需要解析的地址"></a>一、获取需要解析的地址</h1><p>为了确保加载，我解析的地址比较多，其中分为必须和可选（自己加上后发现效果比较好）</p>
<h2 id="必须"><a href="#必须" class="headerlink" title="必须"></a>必须</h2><ul>
<li>gist.github.com</li>
<li>github.com</li>
<li>assets-cdn.github.com</li>
<li>github.global.ssl.fastly.net</li>
</ul>
<h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><ul>
<li><a href="http://www.github.com" target="_blank" rel="noopener">www.github.com</a></li>
<li>api.github.com</li>
<li>github.githubassets.com</li>
<li>github.map.fastly.net</li>
<li>raw.githubusercontent.com</li>
<li>avatars0.githubusercontent.com</li>
<li>avatars1.githubusercontent.com</li>
<li>avatars2.githubusercontent.com</li>
<li>avatars3.githubusercontent.com</li>
</ul>
<h2 id="如何有针对性的选择添加解析的域名"><a href="#如何有针对性的选择添加解析的域名" class="headerlink" title="如何有针对性的选择添加解析的域名"></a>如何有针对性的选择添加解析的域名</h2><p>在加载github的时候打开开发者模式（F12），选择网络（Network），观察加载比较慢的或者直接加载失败的。</p>
<img src="/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/p1.png" class="" width="300" title="Network-Screenshot">

<p>如图，可以看到头像是加载失败的，找到网址是：avatars0.githubusercontent.com，把它加入需要解析的地址</p>
<h1 id="二、获取Github的DNS解析地址"><a href="#二、获取Github的DNS解析地址" class="headerlink" title="二、获取Github的DNS解析地址"></a>二、获取Github的DNS解析地址</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>采用<a href="https://www.ipaddress.com/ip-lookup" target="_blank" rel="noopener">IPAddress.com</a>查询ip地址。</p>
<p>输入需要查找的网址，如：assets-cdn.github.com，就可以看到结果。</p>
<img src="/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/ip1.png" class="" width="400" title="Find-ip">

<p>可以看到assets-cdn.github.com有四个对应ip</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>在用方法一的时候，发现电脑本来自动加载的ip和搜索出来的ip相差很大，因此可以直接采用电脑本来自己加载的时候采用的ip。</p>
<img src="/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/ip2.png" class="" title="Auto-ip">

<p>又或者如果有自己的服务器可以尝试用服务器ping一下查看服务器所找到的ip。</p>
<p>又又或者直接试试网上别人提供的ip。</p>
<h1 id="三、修改Hosts文件"><a href="#三、修改Hosts文件" class="headerlink" title="三、修改Hosts文件"></a>三、修改Hosts文件</h1><p>打开系统的hosts文件，Windows是在<code>C:\Windows\System32\drivers\etc</code>，Mac和Linux是在<code>/etc</code><br>均需要采用管理员（root）打开</p>
<p>在文件最后加上需要的ip和域名对应的地址，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.255.112 gist.github.com</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<h1 id="四、刷新DNS缓存"><a href="#四、刷新DNS缓存" class="headerlink" title="四、刷新DNS缓存"></a>四、刷新DNS缓存</h1><p>对于Windwos用户，需要刷新一下DNS缓存</p>
<p>打开<code>cmd</code>或<code>powershell</code><br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>

<p>这样就可以使用我们自定义的hosts了</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>这其实是一个硬方法，由于ip可能会变且存在很多不同的ip，采用自定义ip其实并没有那么方便，一是不一定能找到最快的ip，二是一旦ip修改还得自行修改hosts文件，并没有那么方便。<br>但网上搜索了那么多，也没有找到一些好的方法，就先选择采用这个方法吧。</p>
<p>ps.几年前的采用修改hosts的方法是可以当半个梯子用的，不过现在好像并不太好用了。。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>DNS</tag>
        <tag>Hosts</tag>
      </tags>
  </entry>
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <url>/2020/02/23/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%EF%BC%89/</url>
    <content><![CDATA[<p>本文针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）</p>
<p>Next默认是会显示全文的，这样显然很不方便，因此需要一些方法去只显示前面一部分。</p>
<a id="more"></a>

<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后有两种方法</p>
<h2 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h2><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p>
<h2 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h2><p>在需要截断的地方加入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到<code>修改配置</code>上面。</p>
<p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python触发win10通知栏通知提醒</title>
    <url>/2020/02/11/Python%E8%A7%A6%E5%8F%91win10%E9%80%9A%E7%9F%A5%E6%A0%8F%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[<p>在写代码的时候想在某些特定情况触发提示（后台自动运行的情况下），可以搜到的大部分是右下角提示之类比较丑的自定义提示，而其实现在win10已经有自己的通知栏，如果能用自带的通知栏绝对是一个很优秀的选择。搜了很久后发现了一个库叫做<strong>win10toast</strong>。</p>
<p>这个库最后是18年更新的，感觉是不会有更新了，但只要不会出问题就好，开发者github：<a href="https://github.com/jithurjacob/Windows-10-Toast-Notifications" target="_blank" rel="noopener">jithurjacob/Windows-10-Toast-Notifications</a></p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用pip安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install win10toast</span><br></pre></td></tr></table></figure>

<p>这个需要同时安装<strong>pywin32</strong>，没有安装的话pip会自动一起安装的。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> win10toast <span class="keyword">import</span> ToastNotifier</span><br><span class="line"></span><br><span class="line">toaster = ToastNotifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有icon的版本</span></span><br><span class="line">toaster.show_toast(<span class="string">"Hello World!!!"</span>,</span><br><span class="line">                   <span class="string">"Python is 10 seconds awsm!"</span>,</span><br><span class="line">                   icon_path=<span class="string">"custom.ico"</span>,</span><br><span class="line">                   duration=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无icon，采用python的icon，且采用自己的线程</span></span><br><span class="line">toaster.show_toast(<span class="string">"Example two"</span>,</span><br><span class="line">                   <span class="string">"This notification is in it's own thread!"</span>,</span><br><span class="line">                   icon_path=<span class="literal">None</span>,</span><br><span class="line">                   duration=<span class="number">5</span>,</span><br><span class="line">                   threaded=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待提示框关闭</span></span><br><span class="line"><span class="keyword">while</span> toaster.notification_active(): time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p>提示框截图：</p>
<img src="/2020/02/11/Python%E8%A7%A6%E5%8F%91win10%E9%80%9A%E7%9F%A5%E6%A0%8F%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92/screenshot.png" class="" title="Screenshot">
<p>本来想要一个可以永久长时间需要手动关闭的提示框，可惜似乎开发者并没有支持，经过尝试采用-1是有效的，但是会报错。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/104270913" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/104270913</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Python</tag>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装MPICH3.3.2</title>
    <url>/2019/11/23/Ubuntu%E5%AE%89%E8%A3%85MPICH3-3-2/</url>
    <content><![CDATA[<p>Linux上安装MPICH还算是方便的，虽然是indows系统，但搜索了一下windows安装的方法，最后选择放弃windows选择linux，不过虚拟机上的性能可能稍微差一点，但是作为并行的入门使用还是没有问题的。</p>
<p>主要步骤一开始是跟着网上搜索的，后来发现其实自带的readme写得很详细，推荐如果英文ok看readme就好。</p>
<a id="more"></a>

<p>此安装步骤成功安装于Ubuntu 16和Ubuntu 18。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>官网：<a href="https://www.mpich.org/" target="_blank" rel="noopener">https://www.mpich.org/</a><br>点击download以后选择<strong>mpich-3.3.2 (stable release)</strong>，下面自带的ubuntu平台的没太看懂于是就放弃了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载好以后解压并打开目录：（其实更喜欢右键解压哈哈哈）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzf mpich-3.3.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mpich-3.3.2</span><br></pre></td></tr></table></figure>

<p>如果看一下Readme的话可以发现必须要的是gcc，可选g++和Fortran。没有安装c的编译器的自行搜索</p>
<p>然后配置文件（这里没有用readme的重定向因为感觉看起来方便）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure -prefix=/usr/<span class="built_in">local</span>/mpich</span><br></pre></td></tr></table></figure>

<p>这里prefix是安装路径<br>如果有Fortran报错，又不需要支持Fortran的话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure -prefix=/usr/<span class="built_in">local</span>/mpich --<span class="built_in">disable</span>-fortran</span><br></pre></td></tr></table></figure>

<p>然后make file（此处等待5分钟）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>然后安装（此处继续等待五分钟）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>如果出错的话可以尝试make clean然后再来一遍</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>为了能全局使用，我们需要配置一下环境变量。这里被坑了很久，因为网上都是bash的配置，但我的默认shell是zsh，然后就一直配不出。。。</p>
<p>如果配置的是bash，打开bash的环境变量配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>如果是zsh，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<h1 id="编辑环境变量"><a href="#编辑环境变量" class="headerlink" title="编辑环境变量"></a>编辑环境变量</h1><p>输入<strong>G</strong>移到最后一行，<br>按下<strong>i</strong>进行编辑<br>加入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpich/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后按下<strong>ESC</strong>，以及 <strong>:wq</strong>保存退出。</p>
<p>然后刷新一下环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>然后输入以下命令测试，应该会有反应</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> mpicc</span><br><span class="line"><span class="built_in">which</span> mpiexec</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/103212344" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/103212344</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MPICH</tag>
        <tag>Ubuntu</tag>
        <tag>parallelism</tag>
      </tags>
  </entry>
  <entry>
    <title>修改服务器端口</title>
    <url>/2019/10/01/%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>自己建一个服务器，最基础会遇到的问题就是被人随机攻击服务器，把默认端口修改掉就会减少很多啦</p>
<a id="more"></a>

<p>登录服务器以后，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>然后会看到一行被注释的 #port 22</p>
<p>把”#”删掉然后把22换成其它端口号就好。</p>
<p>关于vim使用，要修改之前按一下i，修改结束按esc，然后输入”:wq”。</p>
<p>最后重新刷新一下配置（Debian 9）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<p>如不成功，可尝试以下命令：（Centos 7）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<p>然后可以先试一下用默认端口登录，发现不可以登录</p>
<p>之后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@xxx.xxx.xx.xx -p abcd(端口号)</span><br></pre></td></tr></table></figure>

<p>会发现让输入密码，那就成功修改端口啦</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/101845927" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/101845927</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习-Calendar类</title>
    <url>/2019/09/25/JAVA%E5%AD%A6%E4%B9%A0-Calendar%E7%B1%BB/</url>
    <content><![CDATA[<p>Calendar类实个挺神奇的类，具体原因也没有细究，记一下它的用法。</p>
<p>Calendar类是一个基于Date类的类，它其中用到了Date，并且有相应的方法。而Calendar比Date增加了一些更通用的甚至，比如可以单独甚至年月日。</p>
<a id="more"></a>

<h1 id="新建一个（假）实例"><a href="#新建一个（假）实例" class="headerlink" title="新建一个（假）实例"></a>新建一个（假）实例</h1><p>和其他很多函数用法不一样，Calendar不用new来新建一个实例，而是用Calendar.getInstance()，因为某些原因所以我叫它（假）实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<p>这样我们就拥有了一个时间为现在时间的Calendar类c了。</p>
<h1 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h1><p>Calendar有两种设置方法。</p>
<h2 id="调用set"><a href="#调用set" class="headerlink" title="调用set"></a>调用set</h2><p>第一种调用set，用法是set(变量，值)<br>变量可以是Calendar.HOUR, Calendar.YEAR 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br></pre></td></tr></table></figure>

<p>这样年份就变成了2019</p>
<h2 id="调用setTime"><a href="#调用setTime" class="headerlink" title="调用setTime"></a>调用setTime</h2><p>setTime就是一个和Date有关的方法了，它的传参是一个Date类，为什么要用Date呢，因为Date的日期计算方式是距离一个年份的毫秒数，个人猜测比较方便。<br>用法就是setTime(date)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">c.setTime(d);</span><br></pre></td></tr></table></figure>

<h2 id="复制另一个Calendar时间"><a href="#复制另一个Calendar时间" class="headerlink" title="复制另一个Calendar时间"></a>复制另一个Calendar时间</h2><p>Calendar有一个方法是getTime()返回的是一个Date类，和setTime很像，因此我的解决方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">Calendar c2 = Calendar.getInstance();</span><br><span class="line">c1.setTime(c2.getTime());</span><br></pre></td></tr></table></figure>


<h1 id="Assert的使用"><a href="#Assert的使用" class="headerlink" title="Assert的使用"></a>Assert的使用</h1><p>这里就是为什么我认为我们构建的是一个（假）实例了。<br>阅读下述代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">Calendar c2 = Calendar.getInstance();</span><br><span class="line">assertEquals(c1, c2);</span><br></pre></td></tr></table></figure>
<p>它是不会报错的，十分神奇。。</p>
<p>再看另一端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">Calendar c2 = Calendar.getInstance();</span><br><span class="line">c1.set(Calendar.YEAR, <span class="number">1999</span>);</span><br><span class="line">assertEquals(c1, c2);</span><br></pre></td></tr></table></figure>
<p>当我们修改了年份以后，它是会报错的。</p>
<p>因此，我们得出的结论对于Calendar的assert，它只是对比了日期是否相同，并不对比指针是否一致</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/101376719" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/101376719</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7安装MariaDB数据库及基础配置</title>
    <url>/2019/07/18/CentOS-7%E5%AE%89%E8%A3%85MariaDB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为开发需求，在自己的CentOS 7服务器上远程链接数据库，搜索得知CentOS 7默认是MariaDB数据库而非MySQL。虽然安装MySQL也不是不可以，但是既然MariaDB和MySQL很像，那就直接上MariaDB吧。<br>安装教程是搜到的英文教程，主要是用来记录和帮助一些人翻译一下的。</p>
<a id="more"></a>

<h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><h2 id="一、增加MariaDB-Yum"><a href="#一、增加MariaDB-Yum" class="headerlink" title="一、增加MariaDB Yum"></a>一、增加MariaDB Yum</h2><p>首先需要新增一个文件，这边用vim写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/MariaDB.repo</span><br></pre></td></tr></table></figure>
<p>在这个文件中加入这些内容，如果不会用vim的首先按<strong>i</strong>，然后粘贴上去，在按<strong>ESC</strong>，最后输入 <strong>:wq</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mariadb]</span><br><span class="line">name &#x3D; MariaDB</span><br><span class="line">baseurl &#x3D; http:&#x2F;&#x2F;yum.mariadb.org&#x2F;10.1&#x2F;centos7-amd64</span><br><span class="line">gpgkey &#x3D; https:&#x2F;&#x2F;yum.mariadb.org&#x2F;RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck &#x3D; 1</span><br></pre></td></tr></table></figure>

<h2 id="二、安装MariaDB"><a href="#二、安装MariaDB" class="headerlink" title="二、安装MariaDB"></a>二、安装MariaDB</h2><p>最好在root用户下安装（非root用户我后面几个命令报错了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mariadb mariadb-server</span><br></pre></td></tr></table></figure>

<h2 id="三、配置MariaDB"><a href="#三、配置MariaDB" class="headerlink" title="三、配置MariaDB"></a>三、配置MariaDB</h2><p>启动mariadb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mariadb</span><br></pre></td></tr></table></figure>

<p>设置开机自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br></pre></td></tr></table></figure>

<p>设置root密码等相关，这其中包括密码等一些基本设置，一开始是没有密码的，所以按回车就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>

<h2 id="四、登录"><a href="#四、登录" class="headerlink" title="四、登录"></a>四、登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h2 id="五、查看版本"><a href="#五、查看版本" class="headerlink" title="五、查看版本"></a>五、查看版本</h2><p>MariaDB还真是MySQL的亲家，查看版本命令竟然使用mysql的。。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -V</span><br></pre></td></tr></table></figure>

<h2 id="六、新增用户"><a href="#六、新增用户" class="headerlink" title="六、新增用户"></a>六、新增用户</h2><p>登录到root用户到数据库下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.user(Host,<span class="keyword">User</span>,<span class="keyword">Password</span>) <span class="keyword">values</span>(<span class="string">"localhost"</span>,<span class="string">"admin"</span>,<span class="keyword">password</span>(<span class="string">"admin"</span>));</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<h2 id="七、开启远程访问"><a href="#七、开启远程访问" class="headerlink" title="七、开启远程访问"></a>七、开启远程访问</h2><p>首先登录到root用户下数据库，然后输入以下句子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<p>其中‘root’可以替换成任何已创建的用户，‘123456’处是密码。<br>这样就可以远程访问了。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/96387164" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/96387164</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MariaDB</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 基础语句</title>
    <url>/2019/05/11/SQL-%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<ul>
<li>SQL不区分大小写</li>
<li>SQL需要分号<a id="more"></a>

</li>
</ul>
<h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><h2 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">table</span>] <span class="keyword">AS</span> [<span class="keyword">select</span> <span class="keyword">statement</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#样例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">38</span> <span class="keyword">AS</span> altitude, <span class="number">122</span> <span class="keyword">AS</span> longitude, “Berkeley” <span class="keyword">AS</span> <span class="keyword">name</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">42</span>,             <span class="number">71</span>,               <span class="string">"Cambridge"</span>        <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">45</span>,             <span class="number">93</span>,               <span class="string">"Minneapolis"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">table</span>] [(create_definition,...)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#用法样例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> numbers (n, note);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> numbers (n <span class="keyword">UNIQUE</span>, note);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> numbers (n, note <span class="keyword">DEFAULT</span> <span class="string">"No comment"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>UNIQUE</strong>: 使得n是唯一的<br><strong>DEFAULT</strong>: 设置默认值</p>
<h1 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [<span class="keyword">table</span>];        <span class="comment">#删除表</span></span><br></pre></td></tr></table></figure>

<h1 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">table</span>] <span class="keyword">VALUES</span> [(<span class="keyword">value</span>)];         <span class="comment">#对一个表进行一整行的插入</span></span><br><span class="line"><span class="comment">#example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> numbers <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">"a"</span>), (<span class="number">5</span>, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">table</span>(<span class="keyword">key</span>)] <span class="keyword">VALUES</span> [(<span class="keyword">value</span>)];    <span class="comment">#对一个表的某几列进行插入，剩下默认为null</span></span><br><span class="line"><span class="comment">#example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> numbers(n) <span class="keyword">VALUES</span> (<span class="number">0</span>), (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">table</span>] [<span class="keyword">select</span> <span class="keyword">statement</span>];       <span class="comment">#用select来插入</span></span><br><span class="line"><span class="comment">#example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> numbers(n) <span class="keyword">SELECT</span> n+<span class="number">8</span> <span class="keyword">from</span> numbers;</span><br></pre></td></tr></table></figure>

<h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [<span class="keyword">table</span>] <span class="keyword">SET</span> [<span class="keyword">statement</span>] <span class="keyword">WHERE</span> [<span class="keyword">statement</span>];   <span class="comment">#通过where筛选需要更新的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">UPDATE</span> numbers <span class="keyword">SET</span> note = <span class="string">"aaa"</span> <span class="keyword">WHERE</span> n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [<span class="keyword">table</span>] <span class="keyword">WHERE</span> [<span class="keyword">statement</span>];           <span class="comment">#通过where筛选需要删除的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> numbers <span class="keyword">WHERE</span> note = <span class="string">"No comment"</span>;</span><br></pre></td></tr></table></figure>

<h1 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [expression] <span class="keyword">AS</span> [<span class="keyword">name</span>], [expression] <span class="keyword">AS</span> [<span class="keyword">name</span>], …;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">columns</span>] <span class="keyword">FROM</span> [<span class="keyword">table</span>] <span class="keyword">WHERE</span> [condition] <span class="keyword">ORDER</span> <span class="keyword">BY</span> [<span class="keyword">order</span>] <span class="keyword">LIMIT</span> [<span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># exapmle 1</span></span><br><span class="line"><span class="keyword">SELECT</span> a.parent, b.child</span><br><span class="line"><span class="keyword">FROM</span> parents <span class="keyword">AS</span> a, parents <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.child = b.parent;</span><br><span class="line"></span><br><span class="line"><span class="comment"># example 2</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grandparents <span class="keyword">AS</span></span><br><span class="line"> <span class="keyword">SELECT</span> a.parent <span class="keyword">AS</span> grandog, b.child <span class="keyword">AS</span> granpup</span><br><span class="line">   <span class="keyword">FROM</span> parents <span class="keyword">AS</span> a, parents <span class="keyword">AS</span> b</span><br><span class="line">   <span class="keyword">WHERE</span> b.parent = a.child;</span><br></pre></td></tr></table></figure>


<h1 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC      <span class="comment">#降序</span></span><br><span class="line">ASC       <span class="comment">#升序（默认）</span></span><br><span class="line"></span><br><span class="line">order by A,B             <span class="comment">#这个时候都是默认按升序排列</span></span><br><span class="line">order by A desc,B        <span class="comment">#这个时候 A 降序，B 升序排列</span></span><br><span class="line">order by A ,B desc       <span class="comment">#这个时候 A 升序，B 降序排列</span></span><br></pre></td></tr></table></figure>


<h1 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">max()</span><br><span class="line">min()</span><br><span class="line">avg()</span><br><span class="line">sum()</span><br><span class="line">count()</span><br></pre></td></tr></table></figure>

<h1 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">columns</span>] <span class="keyword">from</span> [<span class="keyword">table</span>] <span class="keyword">group</span> <span class="keyword">by</span> [expression] <span class="keyword">having</span> [expression];</span><br></pre></td></tr></table></figure>



<h1 id="Numerical-Expressions"><a href="#Numerical-Expressions" class="headerlink" title="Numerical Expressions"></a>Numerical Expressions</h1><p>Combine values:   +, -, *, /, %, and, or<br>Transform values: abs, round, not, -<br>Compare values:   &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, !=, =</p>
<h1 id="String-Expressions"><a href="#String-Expressions" class="headerlink" title="String Expressions"></a>String Expressions</h1><p>Combine: ||        字符串拼接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT <span class="string">"hello,"</span> || <span class="string">" world"</span>;</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<p>substr(string, start_index, length)    获取字串，start_index从1开始<br>instr(string, substring)                      查找substring在string中的index</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE TABLE phrase AS SELECT <span class="string">"hello, world"</span> AS s;</span><br><span class="line">sqlite&gt; SELECT substr(s, 4, 2) || substr(s, instr(s, <span class="string">" "</span>)+1, 1) FROM phrase;</span><br><span class="line">low</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/90105733" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/90105733</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode——415. Add Strings(大数加法)</title>
    <url>/2019/03/02/Leetcode%E2%80%94%E2%80%94415-Add-Strings-%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>
</blockquote>
<a id="more"></a>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题很明显就是一个字符串的大数相加。</p>
<p>首先相同位数的相加，然后考虑一下进位符。<br>如果一个数没有第k位，那么和的第k位就是另一个数的第k位和进位符相加。<br>最后需要注意以下最后会不会有多出一个进位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = k;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t += num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t += num1[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t += num2[j] + num1[i] - <span class="string">'0'</span> - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = t / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="string">'0'</span> + t % <span class="number">10</span>;</span><br><span class="line">            s = c + s;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="string">"1"</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/88075414" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/88075414</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>新版OpenGL学习入门（三）——对着色器的一些理解</title>
    <url>/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>在写完OpenGL项目后，再次回顾并总结一下用到的一些知识。</p>
<p><em>注意此博文可能需要先入门，否则可能有些难懂</em></p>
<p>我做了一个简易的皮卡丘版的跳一跳，有兴趣的可以看一下我的Github：<a href="https://github.com/yueyue200830/Jumping-Pikachu" target="_blank" rel="noopener">Jumping Pikachu</a></p>
<img src="/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/Pikachu.png" class="" title="Pikachu">

<p>整个项目的一个亮点是在跳跃失败了以后会产生爆破的效果，这个效果需要用到<strong>几何着色器</strong>。</p>
<h1 id="关于着色器"><a href="#关于着色器" class="headerlink" title="关于着色器"></a>关于着色器</h1><p>我整个项目的学习链接：<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL</a></p>
<blockquote>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，3D坐标转为2D坐标的处理过程叫做<strong>图形渲染管线</strong></p>
</blockquote>
<p>而在图形渲染管线也分为好几个步骤，以下为图示</p>
<img src="/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/pipeline.png" class="" title="图形渲染管线的过程">

<p>其中三个着色器就是把数据处理成另一类数据然后交给下一个着色器继续处理，最后出来就是我们要的内容了。</p>
<ul>
<li><strong>顶点着色器(vs)</strong> 是最初用来处理顶点坐标的，一般会对坐标做一些计算</li>
<li><strong>几何着色器(gs)</strong> 是对原坐标进行一些修改，个人感觉适用于一些特效</li>
<li><strong>片段着色器(fs)</strong> 是对图形进行涂色，并最终输出。</li>
</ul>
<p>注意：这三个顺序是固定的，其中几何着色器并不是一定要用的。</p>
<h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>一般一个点储存了它的三维坐标、三维法向量和二维的纹理坐标。<br>其中法向量是为了计算光线的，而纹理坐标则是为了纹理贴图。</p>
<p>以下的代码是我项目中的，其中out是传到后面一个着色器的东西，而gl_Position是该点的输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">version <span class="number">330</span> core</span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 aTexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">	vec3 FragPos;</span><br><span class="line">	vec3 Normal;</span><br><span class="line">    vec2 texCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vs_out.FragPos = vec3(model * vec4(aPos, <span class="number">1.0</span>));</span><br><span class="line">	vs_out.Normal = mat3(transpose(inverse(model))) * aNormal;</span><br><span class="line">    vs_out.texCoords = aTexCoords;</span><br><span class="line"></span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>集合着色器可以对坐标进行一些修改，而我的项目中皮卡丘爆破的场景就是通过这个进行修改的。</p>
<p>爆破的效果是通过对每一个碎片向它的法向量移动一段距离而获得的，一下是教程中的爆破效果。</p>
<img src="/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/geometry_shader_explosion.png" class="" title="爆破">

<p>以下是我项目的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (triangles) in;</span><br><span class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">	vec3 FragPos;</span><br><span class="line">	vec3 Normal;</span><br><span class="line">    vec2 texCoords;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 Normal;</span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function">vec4 <span class="title">explode</span><span class="params">(vec4 position, vec3 normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> magnitude = <span class="number">2.0</span>;</span><br><span class="line">	vec3 direction;</span><br><span class="line">	vec4 temp;</span><br><span class="line">	<span class="keyword">if</span> (time &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">		direction = normal * (-<span class="built_in">log</span>(<span class="number">1.0</span>- time)) * magnitude;</span><br><span class="line">		temp = position + vec4(direction, <span class="number">0.0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		temp = position;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">GetNormal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 a = vec3(gl_in[<span class="number">0</span>].gl_Position) - vec3(gl_in[<span class="number">1</span>].gl_Position);</span><br><span class="line">    vec3 b = vec3(gl_in[<span class="number">2</span>].gl_Position) - vec3(gl_in[<span class="number">1</span>].gl_Position);</span><br><span class="line">    <span class="keyword">return</span> normalize(cross(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec3 normal = GetNormal();</span><br><span class="line"></span><br><span class="line">    gl_Position = explode(gl_in[<span class="number">0</span>].gl_Position, normal);</span><br><span class="line">	Normal = gs_in[<span class="number">0</span>].Normal;</span><br><span class="line">	FragPos = gs_in[<span class="number">0</span>].FragPos;</span><br><span class="line">    TexCoords = gs_in[<span class="number">0</span>].texCoords;</span><br><span class="line">    EmitVertex();</span><br><span class="line">    gl_Position = explode(gl_in[<span class="number">1</span>].gl_Position, normal);</span><br><span class="line">	Normal = gs_in[<span class="number">1</span>].Normal;</span><br><span class="line">	FragPos = gs_in[<span class="number">1</span>].FragPos;</span><br><span class="line">    TexCoords = gs_in[<span class="number">1</span>].texCoords;</span><br><span class="line">    EmitVertex();</span><br><span class="line">    gl_Position = explode(gl_in[<span class="number">2</span>].gl_Position, normal);</span><br><span class="line">	Normal = gs_in[<span class="number">2</span>].Normal;</span><br><span class="line">	FragPos = gs_in[<span class="number">2</span>].FragPos;</span><br><span class="line">    TexCoords = gs_in[<span class="number">2</span>].texCoords;</span><br><span class="line">    EmitVertex();</span><br><span class="line">    EndPrimitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>片段着色器就是最后进行上色的部分，由于颜色的亮度和光照有关，因此其中包含计算光照和颜色。<br>对于不同反射等计算是比较困难的，我就借鉴了教程上的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Material</span> &#123;</span></span><br><span class="line">    sampler2D diffuse;</span><br><span class="line">    sampler2D specular;</span><br><span class="line">    <span class="keyword">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirLight</span> &#123;</span></span><br><span class="line">    vec3 direction;</span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 Normal;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform DirLight dirLight;</span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">CalcDirLight</span><span class="params">(DirLight light, vec3 normal, vec3 viewDir)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 norm = normalize(Normal);</span><br><span class="line">    vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">	vec3 result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line"></span><br><span class="line">	FragColor = vec4(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">CalcDirLight</span><span class="params">(DirLight light, vec3 normal, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 lightDir = normalize(-light.direction);</span><br><span class="line">    <span class="comment">// diffuse shading</span></span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// specular shading</span></span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// combine results</span></span><br><span class="line">    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，着色器虽然较难入手，但是着色器可以很有效的帮助我们进行变换等其他操作，尤其是十分优秀的几何着色器。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/88071644" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/88071644</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL——next_permutation&amp;prev_permutation</title>
    <url>/2019/02/07/STL%E2%80%94%E2%80%94next-permutation-prev-permutation/</url>
    <content><![CDATA[<p>next_permutation和prev_permutation是对c++求全排列的函数，分别可以求出下一个全排列和前一个全排列。</p>
<a id="more"></a>

<p>这里以next_permutation为例，来看一下c++官网的定义：</p>
<blockquote>
<p>default: bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);<br>custom: bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);</p>
</blockquote>
<p>可以看到和sort的用法很像，只需要输入first和last就可以返回是否有下一个，如果有的话会直接在内部排序出现下一个。</p>
<p>同时可以选项是comp函数，可以自定义排序方式，默认为字典序。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>题目：<a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">leetcode 46. Permutations</a></p>
<p>这是一道全排列的题目，普通解法有dfs和非递归的查找，看解答时发现了这个函数，减少了不少代码量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        ans.push_back(nums);</span><br><span class="line">        <span class="keyword">while</span> (next_permutation(nums.begin(), nums.end())) &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/86771956" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/86771956</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode——42. Trapping Rain Water</title>
    <url>/2019/02/03/Leetcode%E2%80%94%E2%80%9442-Trapping-Rain-Water/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
</blockquote>
<a id="more"></a>

<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>输入：[0,1,0,2,1,0,1,3,2,1,2,1]<br>答案：6（蓝色部分）</p>
<img src="/2019/02/03/Leetcode%E2%80%94%E2%80%9442-Trapping-Rain-Water/rainwatertrap.png" class="" title="example">


<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>本题就是需要寻找凹下去比旁边低的部分。</p>
<p>对于题意的分析部分比较难，如果能正确分析出题意基本就可以解决了。</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>这个解法是官方的解法，主要写一下思路：</p>
<p>对于每一条块，把它左边和右边的块一份为二，分别寻找出它左边和右边最高块的高度，显然它最后加了水的高度就是它左右两遍高度的最大值中小的那个。</p>
<img src="/2019/02/03/Leetcode%E2%80%94%E2%80%9442-Trapping-Rain-Water/solution.png" class="" title="solution">

<p>如图红色为随机的一条，两条黑色的是其左右两边最高的两根，显然最后注满的水量至少之蓝色这么多，也就是左右两根黑色中比较矮的那根的长度。</p>
<p>因此<strong>sum  = sum(min(left_max[i], right_max[i]))</strong></p>
<p>比较普通又方便的一种解法是用dp记录left_max和right_max，时间复杂度和空间复杂度都为O(n)。</p>
<p>而另一种可以更快的方法是用left和right两个来左右一起遍历，同时记录遍历过的left_max和right_max。<br>只要比较现在遍历过的里面左右的最大值，最大值比较小的那侧现在指向的那块最后的注水量就是那侧遍历到的最大的值。（因为另一侧的最大值一定比这一侧的最大值大）<br>即，假设现在left_max比right_max小，那么第left个左边所有的值都知道了，最大值为left_max，而它右边的最大值一定会大于等于right_max。因此min(right_max[i], left_max[i]) = left_max[i]。<br>这样遍历的时间复杂度是O(n)（只需要遍历n次，比dp的2n次少一半），空间复杂度为O(1)（只需要另外4个数记录就好，而dp的额外空间是2n）</p>
<p>附上官方代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">      height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);</span><br><span class="line">      ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);</span><br><span class="line">      --right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>这个是我绞尽脑汁后的一个比较复杂的解法，时间复杂度O(n)，空间复杂度最大O(n)（用stack）</p>
<p>做法是从左往右遍历，遇到可以注水的地方就先把暂时可以注的水给注入。</p>
<p>如样例中有一部分[2,1,0,1,3]<br>当遇到右侧1的时候，也就是[2,1,0,1]时，在0中注入1的水量，这样就变成了[2,1,1,1]了<br>当遇到3时，对所有的1都注入1的水量，变成[2,2,2,2,3]。</p>
<p>整个的难点在于用stack的记录，对于同一个高度块只记录一次，每次需要同时记录高度和位置，因此需要用结构体来记录。<br>又由于是从左往右遍历的，每次记录同高度下最右边的那条。</p>
<p>因为每次遍历完已经填平了所有遍历过的水坑，因此stack中记录的一定是不可以再注入水的，也就是递增或者递减的一堆数。</p>
<p>当每次遇到可以注水的时候，注水量为(mini(left_height, right_height) - current_height)*(left_position-right_position-1)（如有不理解可以考虑一下刚才的example）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="keyword">int</span> p;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;num&gt; q;</span><br><span class="line">        num tmp, last;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        tmp.n = height[<span class="number">0</span>];</span><br><span class="line">        tmp.p = <span class="number">0</span>;</span><br><span class="line">        q.push(tmp);</span><br><span class="line">        tmp.n = height[<span class="number">1</span>];</span><br><span class="line">        tmp.p = <span class="number">1</span>;</span><br><span class="line">        q.push(tmp);</span><br><span class="line">        <span class="keyword">int</span> n = max(height[<span class="number">0</span>], height[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">            tmp = q.top();</span><br><span class="line">            <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span> &amp;&amp; n &gt; tmp.n &amp;&amp; tmp.n &lt;= height[i]) &#123;</span><br><span class="line">                last = tmp;</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp = q.top();</span><br><span class="line">                s += (min(tmp.n, height[i]) - last.n) * (i - tmp.p - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.n = height[i];</span><br><span class="line">            tmp.p = i;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.n &gt; n) &#123;</span><br><span class="line">                n = tmp.n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/86755967" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/86755967</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用wget的方法</title>
    <url>/2019/01/02/windows%E4%B8%8B%E4%BD%BF%E7%94%A8wget%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>GNU Wget（常简称为Wget）是一个在网络上进行下载的简单而强大的自由软件，其本身也是GNU计划的一部分。<br>它的名字是“World Wide Web”和“Get”的结合，同时也隐含了软件的主要功能。<br>当前它支持通过HTTP、HTTPS，以及FTP这三个最常见的TCP/IP协议协议下载。</p>
</blockquote>
<p>wget在linux下很方便就可以安装使用了，但似乎官网并没有给windows下一个安装包之类的东西，搜了好久后来发现了两个解决方法。</p>
<a id="more"></a>

<h1 id="用choco安装"><a href="#用choco安装" class="headerlink" title="用choco安装"></a>用choco安装</h1><p>这是我在自己电脑上方法，不过似乎下面一个方法更加方便删除</p>
<h2 id="安装chocolatey"><a href="#安装chocolatey" class="headerlink" title="安装chocolatey"></a>安装chocolatey</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="string">"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe"</span> -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command <span class="string">"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))"</span> &amp;&amp; SET <span class="string">"PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"</span></span><br></pre></td></tr></table></figure>

<h2 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">choco install wget</span><br></pre></td></tr></table></figure>
<p>这样就可以直接使用了</p>
<h1 id="用已编译的包"><a href="#用已编译的包" class="headerlink" title="用已编译的包"></a>用已编译的包</h1><p>有些地方会放出来一些windows下的包，只要在cmd中打开到相应文件夹就可以使用了，或者应该也可以配置环境变量</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85638286" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85638286</a></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（三）——逆元</title>
    <url>/2018/12/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>当运算时需要求模的时候，可以直接做的有+-*但是不满足/</p>
<p>而逆元就是通过某种运算来达到求(a/b)%p的结果</p>
<a id="more"></a>

<blockquote>
<p>当 $b*c ≡ 1$ (mod p)时，</p>
<p>有 (a / b) % p = (a / b * b * c) % p = (a * c) % p</p>
<p>这里c就是b关于p的逆元 </p>
</blockquote>
<p>那么如何求c呢</p>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<p>当p为素数时，有 $a^p$ ≡ a(mod p)</p>
</blockquote>
<p>故有$a^p$ ≡ 1(mod p)</p>
<p>因此a关于p的逆元就是$a^{p-2}$</p>
<p>这个幂可以使用<strong>快速幂</strong>来得出</p>
<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><blockquote>
<p>对于不完全为0的非负整数a,b，必存在整数x,y，满足ax+by=gcd(a,b)</p>
</blockquote>
<p>因此，求a*x≡1(mod p)</p>
<p>即求ax+py=1=gcd(a,b)/gcd(a,b)</p>
<p>也就是先求出ax+py=gcd(a,b)</p>
<p>然后x=x/gcd(a,b)即可</p>
<p>注意：x可能为负的，需要x=x+p</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span>    <span class="comment">//这是扩展欧几里得</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = exgcd(b, a%b, x, y);</span><br><span class="line">    ll tmp = y;</span><br><span class="line">    y = x - a / b * y;</span><br><span class="line">    x = tmp;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k = exgcd(k ,p ,x ,i);</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += p;                     <span class="comment">//防止x为负</span></span><br><span class="line">x = x / k;</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85334843" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85334843</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（二）——快速幂</title>
    <url>/2018/12/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>快速幂是用来解决$n^k \mod N$，将其时间复杂度从 $O(n)$ 减少到 $O(\log n)$ 。</p>
<a id="more"></a>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先，了解一个模运算的概念</p>
<blockquote>
<p>(a+b) mod N = (a mod N + b mod N) mod N</p>
<p>(a * b) mod N = (a mod N * b mod N) mod N</p>
</blockquote>
<p>然后，对于一个数k，把它转换为二进制，</p>
<p>如11 = 1011</p>
<p>那么 $ n^{11} = n^8 * n^2 * n^1 $ 。</p>
<p>于是 $n^{11} \mod N = (n^8 \mod N) * (n^2 \mod N) * (n^1 \mod N)$</p>
<p>那么在循环过程中只需要一直记录$n^{2^m}$，每次判断$2^m$对应$k$的二进制位是$0$（不要）是$1$（要）就可以</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll n, ll k, ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll num = <span class="number">1</span>, t = n;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            num = num * t % N;</span><br><span class="line">        t = t * t % N;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于快速幂的扩展还有一个矩阵快速幂，它是对于矩阵做一个快速幂的处理，可以用于求斐波那契数列第n项模N </p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85333813" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85333813</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（一）——欧几里德算法&amp;扩展欧几里得算法</title>
    <url>/2018/12/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最大公约数-欧几里德算法（gcd）"><a href="#最大公约数-欧几里德算法（gcd）" class="headerlink" title="最大公约数/欧几里德算法（gcd）"></a>最大公约数/欧几里德算法（gcd）</h1><p>欧几里德算法又称辗转相除法，是用于求最大公约数的方法，证明可以度娘。</p>
<p>个人简单脑补就是a和b两个数的模还是a和b的最大公约数</p>
<p>int类型 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span> ? b : gcd(b, a%b);&#125;</span><br></pre></td></tr></table></figure>

<p>long long类型的 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span> ? b : gcd(b, a%b);&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h1><p>概念： </p>
<blockquote>
<p>对于不完全为0的非负整数a,b</p>
<p>必存在整数x,y，满足ax+by = gcd(a, b)</p>
</blockquote>
<p>运用：</p>
<blockquote>
<p>求解ax+by=c，用扩展欧几里得求得后*c/gcd(a,b)</p>
</blockquote>
<p>求a*x≡1(mod p)</p>
<p>即求ax+py=1=gcd(a,b)/gcd(a,b)</p>
<p>也就是先求出ax+py=gcd(a,b)</p>
<p>然后x=x/gcd(a,b)即可</p>
<p>注意：x可能为负的，需要x=x+p</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = exgcd(b, a%b, x, y);</span><br><span class="line">    ll tmp = y;</span><br><span class="line">    y = x - a / b * y;</span><br><span class="line">    x = tmp;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85333585" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85333585</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Nowcoder Girl第二届挑战赛——题解</title>
    <url>/2018/12/24/2018-Nowcoder-Girl%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%8C%91%E6%88%98%E8%B5%9B%E2%80%94%E2%80%94%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>记录一下自己打得如此渣渣还是进了前120，希望面试能顺利，要求不高，第60名就好，我想要奖品，顺便求奖状啊我要奖学金加分（有钱）</p>
<p>Update: 第一次还是挺顺利的，奖品加分都有啦hhh</p>
<p>2020update：都一年过去了，2019也比完了，题目还是没有上来？？？</p>
<a id="more"></a>

<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>这是一道坑题，题意理解错了，是歌曲已经下载的秒数不是从下载到开始过了多少秒。。。</p>
<p>其实就算是一道追及问题吧，求一下下一次重头播放的时候是第几秒</p>
<p>代码等有题目了再更（大概不会有了）</p>
<h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>唔。。这也是坑题一道啊，我看了半天，快1.5小时的时候才改过来，超级浪费时间。。。</p>
<h2 id="求D-x"><a href="#求D-x" class="headerlink" title="求D(x)"></a>求D(x)</h2><p>这就是一道数学题，求$\left(\frac{x}{y}\right)^y$的最大值，其实就是求导。</p>
<p>至于$ \left( \big( \frac{x}{y} \big)^y \right) &gt; 0$怎么求，这就是高数的知识了，对原式先取对数，也就是对$y \ln{\frac{x}{y}}$求导</p>
<p>推导过程就不写了，不会的话翻高数书吧（可能某些地区的高考知识。。）</p>
<p>最后求得$x \leq e * y$</p>
<p>所以在代码里直接$y=x/e$就好</p>
<h2 id="判断是有限小数还是无限小数"><a href="#判断是有限小数还是无限小数" class="headerlink" title="判断是有限小数还是无限小数"></a>判断是有限小数还是无限小数</h2><p>其实对于有限小数，就是要整除$10^n$，因此当且仅当分母只是2和5的倍数时才行。</p>
<p>不过有一个小坑在于记得分子分母需要先约分一下，用gcd求一下就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:gcd(b,a%b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是有限小数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n%<span class="number">2</span> == <span class="number">0</span>) n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n%<span class="number">5</span> == <span class="number">0</span>) n /= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n, i;</span><br><span class="line">    <span class="keyword">double</span> e = <span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &lt;=  n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">int</span>(i/e+<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">int</span> x = gcd(<span class="keyword">int</span>(i),k);</span><br><span class="line">        k /= x;</span><br><span class="line">        <span class="keyword">bool</span> ok = yes(k);</span><br><span class="line">        <span class="keyword">if</span>(ok) s -= <span class="keyword">int</span>(i);</span><br><span class="line">        <span class="keyword">else</span> s += <span class="keyword">int</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>第三题题意又有点坑。。需要所有连续x个都满足才行。。。</p>
<p>感觉读懂题其实就没什么难点了</p>
<p>求出最坏情况就好</p>
<p>这个代码好像本地保存有一点问题，可能最后是在网上直接修改的，我稍微修改了一下，不能保证一定是对的，等题目出来了再检查一下，但思路是没问题的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, x, c, m, i, j, s, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; c &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;j);</span><br><span class="line">        a[j<span class="number">-1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        j += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = x<span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        j += a[i];</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; c) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[k]==<span class="number">1</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[k]++;</span><br><span class="line">            j++;</span><br><span class="line">            s++;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        j -= a[i-x+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他未完待续。。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85236298" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85236298</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习——Servlet+表单提交</title>
    <url>/2018/12/21/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Servlet-%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>网上写servlet的大神不少，记录一下遇到的问题。</p>
<p>配置是ecplise+tomcat9.0</p>
<p>关于servlet的创建方法：项目右键-&gt;new-&gt;servlet，然后package和class的名字随便命名，之后全部默认或者点finish就好。</p>
<img src="/2018/12/21/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Servlet-%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4/p1.png" class="" title="创建servlet">

<ul>
<li>servlet配置现在有两种，网上比较多的是用xml来的，但是新版的可以通过 @配置注解，新生成的servlet是自带的，不需要任何配置</li>
<li>一开始找到了一个直接用service的，但似乎它直接扩展了底层的内容，可以用doget和dopost来解决</li>
<li>中文字符乱码问题，需要设置response.setCharacterEncoding(“UTF-8”)和request.setCharacterEncoding(“UTF-8”)。需要放在最前面，否则可能在传入值了以后就没用了。</li>
</ul>
<p>这里写的是一个实现登录功能的表单提交的servlet，项目名字叫做Servlet_try4，表单一共就user和password两个内容，最后跳转到hellp.jsp显示登录状态</p>
<p>关于表单部分，在form里加上这个就好</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"servlet"</span>  <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至于表单内部的内容，记得写上name，servlet是根据name来获取的。</p>
<p><strong>原来代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class Servlet_try4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/Servlet_try4"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet_try4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Servlet_try4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 设置字符编码</span></span><br><span class="line">		request.setCharacterEncoding(<span class="string">"utf8"</span>);</span><br><span class="line">		<span class="comment">// 从request对象中获取username,password</span></span><br><span class="line">		String username = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">		String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给将要request的对象写入信息</span></span><br><span class="line">		request.setAttribute(<span class="string">"user"</span>, username);</span><br><span class="line">		request.setAttribute(<span class="string">"password"</span>, password);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将页面转发到欢迎页面</span></span><br><span class="line">		RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">"/hello.jsp"</span>);</span><br><span class="line">		dispatcher.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		response.getWriter().append(<span class="string">"Served at: "</span>).append(request.getContextPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class Servlet_try4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/Servlet_try4"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet_try4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Servlet_try4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		response.getWriter().append(<span class="string">"Served at: "</span>).append(request.getContextPath());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置字符编码</span></span><br><span class="line">		request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从request对象中获取username,password</span></span><br><span class="line">		String username = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">		String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给将要request的对象写入信息</span></span><br><span class="line">		request.setAttribute(<span class="string">"user"</span>, username);</span><br><span class="line">		request.setAttribute(<span class="string">"password"</span>, password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">		response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		doGet(request, response);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将页面转发到欢迎页面</span></span><br><span class="line">		RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">"/hello.jsp"</span>);</span><br><span class="line">		dispatcher.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唔。。虽然这个可以成功，但是在后续学习上发现对于表单提交，最好把doGet的内容全部写到doPost里，这里就不更新了，但是希望可以注意一下~</p>
<p>附：<a href="https://blog.csdn.net/qq_26676207/article/details/53483135" target="_blank" rel="noopener">doGet()和doPost()的区别</a></p>
<p>ps.这里只能实现通过submit做一个表单提交，但是对于很多网页来说需要或许数据库也要调用servlet，又或者想要在提交前做一些什么判断，这样子的话可以尝试一下ajax来跳转到servlet。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/84984287" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84984287</a></p>
]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习——MySQL</title>
    <url>/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/</url>
    <content><![CDATA[<p>记录一下初学MySQL，版本：MySQL8.0。</p>
<p>首先直接msi安装MySQL，虽然占内存，但是省力，全部默认即可</p>
<h1 id="新建MySQL"><a href="#新建MySQL" class="headerlink" title="新建MySQL"></a>新建MySQL</h1><p>直接点击默认的那个，然后创建一个schema，改好名字点apply就可以</p>
<img src="/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/p1.png" class="" title="新建schema">

<p>然后在项目的table那边新建table</p>
<img src="/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/p2.png" class="" title="新建table">

<p>这次需要创建列表信息，这样子它可以帮你默认创建一个，很方便，创建好了点apply就好</p>
<img src="/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/p3.png" class="" title="新建列表信息">

<h1 id="连接MySQL到Ecplise"><a href="#连接MySQL到Ecplise" class="headerlink" title="连接MySQL到Ecplise"></a>连接MySQL到Ecplise</h1><p>参考：<a href="https://blog.csdn.net/fanjianwucmx/article/details/54882044" target="_blank" rel="noopener">eclipse连接mysql数据库</a></p>
<p>代码改的是别人的，url是有做过修改，因为第一次没有连接默认的数据库。。</p>
<p>有几个多重定向的报错，选择sql的就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> js_try8_mail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailTry</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 加载数据库驱动 com.mysql.jdbc.Driver</span></span><br><span class="line">		String driver = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">		<span class="comment">// 获取mysql连接地址</span></span><br><span class="line">		String url = <span class="string">"jdbc:mysql://127.0.0.1:3306/163mail?&amp;useSSL=false&amp;serverTimezone=UTC"</span>;</span><br><span class="line">		<span class="comment">// 数据名称</span></span><br><span class="line">		String username = <span class="string">"root"</span>;</span><br><span class="line">		<span class="comment">// 数据库密码</span></span><br><span class="line">		String password = <span class="string">"xxxxxxxx"</span>;</span><br><span class="line">		<span class="comment">// 获取一个数据的连接</span></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 获取连接的一个状态</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(driver);</span><br><span class="line">			<span class="comment">// getConnection()方法，连接MySQL数据库！</span></span><br><span class="line">			conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">			<span class="keyword">if</span> (!conn.isClosed())</span><br><span class="line">				System.out.println(<span class="string">"数据库连接成功！"</span>);</span><br><span class="line">			<span class="comment">// 创建statement类对象，用来执行SQL语句！</span></span><br><span class="line">			Statement Statement = conn.createStatement();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 要执行的SQL语句</span></span><br><span class="line">			String sql = <span class="string">"select * from mail"</span>;</span><br><span class="line">			<span class="comment">// ResultSet类，用来存放获取的结果集！</span></span><br><span class="line">			ResultSet rs = Statement.executeQuery(sql);</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"执行结果如下所示:"</span>);</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"邮箱"</span> + <span class="string">"\t"</span> + <span class="string">"密码"</span>);</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			<span class="keyword">int</span> id;</span><br><span class="line">			String ads = <span class="keyword">null</span>;</span><br><span class="line">			String pwd = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">				id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">				ads = rs.getString(<span class="string">"address"</span>);</span><br><span class="line">				pwd = rs.getString(<span class="string">"password"</span>);</span><br><span class="line">				<span class="comment">// 输出结果</span></span><br><span class="line">				System.out.println(ads + <span class="string">"\t"</span> + pwd);</span><br><span class="line">			&#125;</span><br><span class="line">			rs.close();</span><br><span class="line">			conn.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// 数据库驱动类异常处理</span></span><br><span class="line">			System.out.println(<span class="string">"数据库驱动加载失败！"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			<span class="comment">// 数据库连接失败异常处理</span></span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">			e2.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"数据库数据获取成功！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="安装navicat"><a href="#安装navicat" class="headerlink" title="安装navicat"></a>安装navicat</h1><p>本身对自带的管理器也不反感，可惜Oracle公司所有产品不支持Windows下的高分辨率屏，对于拥有一块2k屏一块3k屏的我来说太难受了。<br>中文管理界面+连接各种不同的数据库实在是太优秀了。</p>
<p>针对遇到的authentication plugin xxx的问题，解答：<a href="https://blog.csdn.net/u011182575/article/details/80821418" target="_blank" rel="noopener">Navicat Premium 12连接MySQL数据库出现Authentication plugin ‘caching_sha2_password’ cannot be loaded的解决方案</a></p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/84995633" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84995633</a></p>
]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>MySQL</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>新版OpenGL学习入门（二）——绘制图形</title>
    <url>/2018/12/01/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<p>教程链接：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好，三角形</a></p>
<p>这一章学的东西超级多，学完也算基本入门啦</p>
<a id="more"></a>

<p>那就从最基础的开始吧</p>
<h1 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h1><p>首先是坐标轴，它是高中数学学的直角坐标系的坐标轴，理解特别简单。</p>
<p>对应的数值需要在-1和1之间，大概类似百分比吧，最后的f代表浮点数。</p>
<p>和顶点对应的是顶点缓冲对象VBO，先是创建一个unsigned int来储存id，然后创建顶点缓冲对象，再是绑定缓冲对象</p>
<p>最后把顶点数据缓冲进去</p>
<p>这里glBufferData最后一个参数是显卡管理给定数据的模式</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GL_STATIC_DRAW</td>
<td align="left">数据几乎不会改变</td>
</tr>
<tr>
<td align="left">GL_DYNAMIC_DRAW</td>
<td align="left">数据会改变很多</td>
</tr>
<tr>
<td align="left">GL_STREAM_DRAW</td>
<td align="left">数据每次绘制都会改变</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点坐标x,y,z，需要在-1到1之间，标准数学坐标轴</span></span><br><span class="line"><span class="comment">//如果是2d的话z变为0</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;                      <span class="comment">//VBO顶点缓冲对象的id</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把新建的缓冲绑定到GL_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br></pre></td></tr></table></figure>

<h1 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h1><p>着色器相关的在后面有详细介绍，这里主要是为了能够编译使用</p>
<h2 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><h3 id="着色器代码"><a href="#着色器代码" class="headerlink" title="着色器代码"></a>着色器代码</h3><p>这是一个非常基础的GLSL顶点着色器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在着色器的使用过程中，一般是另创建文档来使用的，因此在这边为了简单使用，用字符串记录</p>
<p><strong>注意</strong>这个是写在main函数之前的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GLSL顶点着色器，一般来说着色器会写在其它页面</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span>      <span class="comment">//GLSL版本，与OpenGL版本对应</span></span><br><span class="line">	<span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span>  <span class="comment">//可以把vec3的数据看作vec4构造器的参数，最后一个是透视除法（？）</span></span><br><span class="line">	<span class="string">"&#125;\0"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="编译顶点着色器"><a href="#编译顶点着色器" class="headerlink" title="编译顶点着色器"></a>编译顶点着色器</h3><p>这个和VBO类似，先是着色器id，然后创建着色器，再编译着色器，最后判断是否成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译着色器</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;                                       <span class="comment">//创建顶点着色器对象</span></span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);                 <span class="comment">//创建顶点着色器</span></span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);      <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">//判断编译是否成功</span></span><br><span class="line"><span class="keyword">int</span> sucess;                                                      <span class="comment">//获取着色器编译是否成功的参数</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];                                               <span class="comment">//如果编译失败获取失败的内容</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;sucess);         <span class="comment">//检查编译是否成功</span></span><br><span class="line"><span class="keyword">if</span> (!sucess)                                                     <span class="comment">//如果编译失败，输出信息</span></span><br><span class="line">&#123;</span><br><span class="line">	glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPLIATION_FILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>这个几乎和顶点着色器一模一样</p>
<h3 id="着色器代码-1"><a href="#着色器代码-1" class="headerlink" title="着色器代码"></a>着色器代码</h3><p>源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写在同一个.cpp下的话</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 片段着色器同上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line">	<span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>        <span class="comment">//RGB色，最后一个alpha透明度</span></span><br><span class="line">	<span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="编译片段着色器"><a href="#编译片段着色器" class="headerlink" title="编译片段着色器"></a>编译片段着色器</h3><p>这里比上面少了两行报错内容的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译片段着色器，原理基本同上</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;                                     <span class="comment">//创建片段着色器对象</span></span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);             <span class="comment">//创建顶点着色器</span></span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);  <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"><span class="comment">//判断编译是否成功</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)                                                    <span class="comment">//判断编译是否成功</span></span><br><span class="line">&#123;</span><br><span class="line">	glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>着色器程序是类似加载顶点着色器和片段着色器,代码一如既往的相似</p>
<p>顺便最后因为着色器程序全部get啦，那么顶点着色器和片段着色器就不需要留着数据了</p>
<p>其实从某种意义上感觉片段着色器和顶点着色器对于着色器程序做的是一个封装处理，这样易于管理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 着色器程序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;                                      <span class="comment">//创建着色器程序对象</span></span><br><span class="line">shaderProgram = glCreateProgram();                               <span class="comment">//创建着色器程序</span></span><br><span class="line">glAttachShader(shaderProgram, vertexShader);                     <span class="comment">//把顶点着色器附加到着色器程序</span></span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);                   <span class="comment">//把片段着色器附加到着色器程序</span></span><br><span class="line">glLinkProgram(shaderProgram);                                    <span class="comment">//对附加的着色器链接到着色器程序</span></span><br><span class="line"><span class="comment">// 检查链接是否成功</span></span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">	glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除不需要的着色器</span></span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>最后如果要使用着色器的话，需要再while循环函数里写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br></pre></td></tr></table></figure>

<h1 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h1><p>它主要是告诉编译器如何解析顶点一类的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line"><span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br></pre></td></tr></table></figure>

<h1 id="顶点数组对象（VAO）"><a href="#顶点数组对象（VAO）" class="headerlink" title="顶点数组对象（VAO）"></a>顶点数组对象（VAO）</h1><p>VAO是用来记录顶点属性的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure>

<p>源代码有把VAO和VBO合在一起，所以来一个合起来的版本吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO;                 <span class="comment">//VAO顶点数组对象，VBO顶点缓冲对象的id</span></span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);            <span class="comment">//生成顶点数组对象，给VAO这个id</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);                <span class="comment">//绑定VAO</span></span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把新建的缓冲绑定到GL_ARRAY_BUFFER</span></span><br><span class="line"><span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line"><span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br></pre></td></tr></table></figure>

<h1 id="索引缓冲对象（EBO）"><a href="#索引缓冲对象（EBO）" class="headerlink" title="索引缓冲对象（EBO）"></a>索引缓冲对象（EBO）</h1><p>EBO又名IBO，可以设置顶点如何生成三角形</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<p>又是整合版的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO, EBO;            <span class="comment">//VAO顶点数组对象，VBO顶点缓冲对象,EBO索引缓冲对象</span></span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);            <span class="comment">//生成顶点数组对象，给VAO这个id</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);                 <span class="comment">//生成索引缓冲对象，给EBO这个id。类型为GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);                <span class="comment">//绑定VAO</span></span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把VBO绑定到缓冲区GL_ARRAY_BUFFER</span></span><br><span class="line"><span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);     <span class="comment">//把EBO绑定到缓冲区GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class="comment">//设置缓冲区类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line"><span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑防止意外更改</span></span><br><span class="line"><span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line"><span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="生成图形"><a href="#生成图形" class="headerlink" title="生成图形"></a>生成图形</h1><p>最后只要在while里面运行一下就好啦</p>
<h2 id="生成三角形"><a href="#生成三角形" class="headerlink" title="生成三角形"></a>生成三角形</h2><p>这里是用glDrawArrays运行的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br><span class="line">glBindVertexArray(VAO);                  <span class="comment">//每次需要重新绑定一下VAO</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);        <span class="comment">//设置绘制三角形，有3个顶点</span></span><br></pre></td></tr></table></figure>

<h2 id="生成矩形"><a href="#生成矩形" class="headerlink" title="生成矩形"></a>生成矩形</h2><p>生成矩形需要通过两个三角形来绘制</p>
<p>OpenGL这里给人的感觉好蠢。。为什么不能直接生成矩形，想哭。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br><span class="line">glBindVertexArray(VAO);                  <span class="comment">//每次需要重新绑定一下VAO</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="代码总汇"><a href="#代码总汇" class="headerlink" title="代码总汇"></a>代码总汇</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;      <span class="comment">//窗口回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;  <span class="comment">//输入控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings 初始化设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;     <span class="comment">//初始宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;    <span class="comment">//初始高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GLSL顶点着色器，一般来说着色器会写在其它页面</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span>      <span class="comment">//GLSL版本，与OpenGL版本对应</span></span><br><span class="line">	<span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span>  <span class="comment">//可以把vec3的数据看作vec4构造器的参数，最后一个是透视除法（？）</span></span><br><span class="line">	<span class="string">"&#125;\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器同上，这个是管理颜色的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line">	<span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.8f, 1.0f);\n"</span>        <span class="comment">//RGB色，最后一个alpha透明度</span></span><br><span class="line">	<span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// glfw: initialize and configure   不需要做任何改动</span></span><br><span class="line">	glfwInit();                                             <span class="comment">//初始化GLFW</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);          <span class="comment">//主版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);          <span class="comment">//次版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);   <span class="comment">//核心模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    <span class="comment">// 对于OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw 窗口对象   不需要改动</span></span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">//窗口：宽、高、名称。</span></span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)    <span class="comment">//确保正确创建窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);                                       <span class="comment">//设置窗口上下文为当前线程</span></span><br><span class="line">	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    <span class="comment">//告诉glfw窗口大小会根据改变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glad: load all OpenGL function pointers  加载系统相关的OpenGL函数指针地址的函数   不需要改动</span></span><br><span class="line">	<span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译顶点着色器</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;                                       <span class="comment">//创建顶点着色器对象</span></span><br><span class="line">	vertexShader = glCreateShader(GL_VERTEX_SHADER);                 <span class="comment">//创建顶点着色器</span></span><br><span class="line">	glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);      <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">	glCompileShader(vertexShader);</span><br><span class="line">	<span class="comment">// 判断编译是否成功</span></span><br><span class="line">	<span class="keyword">int</span> success;                                                     <span class="comment">//获取着色器编译是否成功的参数</span></span><br><span class="line">	<span class="keyword">char</span> infoLog[<span class="number">512</span>];                                               <span class="comment">//如果编译失败获取失败的内容</span></span><br><span class="line">	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);        <span class="comment">//检查编译是否成功</span></span><br><span class="line">	<span class="keyword">if</span> (!success)                                                    <span class="comment">//如果编译失败，输出信息</span></span><br><span class="line">	&#123;</span><br><span class="line">		glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPLIATION_FILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译片段着色器，原理基本同上</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;                                     <span class="comment">//创建片段着色器对象</span></span><br><span class="line">	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);             <span class="comment">//创建顶点着色器</span></span><br><span class="line">	glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);  <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">	glCompileShader(fragmentShader);</span><br><span class="line">	<span class="comment">// 判断编译是否成功</span></span><br><span class="line">	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success)                                                    <span class="comment">//判断编译是否成功</span></span><br><span class="line">	&#123;</span><br><span class="line">		glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 着色器程序</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;                                      <span class="comment">//创建着色器程序对象</span></span><br><span class="line">	shaderProgram = glCreateProgram();                               <span class="comment">//创建着色器程序</span></span><br><span class="line">	glAttachShader(shaderProgram, vertexShader);                     <span class="comment">//把顶点着色器附加到着色器程序</span></span><br><span class="line">	glAttachShader(shaderProgram, fragmentShader);                   <span class="comment">//把片段着色器附加到着色器程序</span></span><br><span class="line">	glLinkProgram(shaderProgram);                                    <span class="comment">//对附加的着色器链接到着色器程序</span></span><br><span class="line">	<span class="comment">// 检查链接是否成功</span></span><br><span class="line">	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">		glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除不需要的着色器</span></span><br><span class="line">	glDeleteShader(vertexShader);</span><br><span class="line">	glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶点坐标x,y,z，需要在-1到1之间，标准数学坐标轴</span></span><br><span class="line">	<span class="comment">//如果是2d的话z变为0</span></span><br><span class="line">	<span class="keyword">float</span> vertices[] = &#123;                   <span class="comment">//储存的点是x,y,z;x,y,z这样循环的</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;             <span class="comment">//设置顶点练成三角形</span></span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,</span><br><span class="line">		<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO, EBO;            <span class="comment">//VAO顶点数组对象，VBO顶点缓冲对象,EBO索引缓冲对象</span></span><br><span class="line">	glGenVertexArrays(<span class="number">1</span>, &amp;VAO);            <span class="comment">//生成顶点数组对象，给VAO这个id</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;EBO);                 <span class="comment">//生成索引缓冲对象，给EBO这个id。类型为GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line">	glBindVertexArray(VAO);                <span class="comment">//绑定VAO</span></span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把VBO绑定到缓冲区GL_ARRAY_BUFFER</span></span><br><span class="line">	<span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line">	<span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);     <span class="comment">//把EBO绑定到缓冲区GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line">	glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class="comment">//设置缓冲区类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line">	<span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//解绑防止意外更改</span></span><br><span class="line">	<span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line">	<span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span></span><br><span class="line">	glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// render loop  渲染循环，这样可以保持一直运行</span></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输入</span></span><br><span class="line">		processInput(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//渲染指令</span></span><br><span class="line">		glClearColor(<span class="number">0.1f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);    <span class="comment">//设置清空屏幕所用的颜色，每次循环重新渲染，因此需要清空，也因此这是屏幕的背景色。RGB色</span></span><br><span class="line">		glClear(GL_COLOR_BUFFER_BIT);            <span class="comment">//清楚颜色缓冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br><span class="line">		glBindVertexArray(VAO);                  <span class="comment">//每次需要重新绑定一下VAO</span></span><br><span class="line">		glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);    <span class="comment">//6个顶点</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查并调用事件、交换缓冲</span></span><br><span class="line">		glfwSwapBuffers(window);      <span class="comment">//交换颜色缓冲</span></span><br><span class="line">		glfwPollEvents();             <span class="comment">//检查事件触发</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">	glfwTerminate();     <span class="comment">//终止glfw</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)    <span class="comment">//判断是否按下Esc</span></span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);               <span class="comment">//如果时Esc，那么glfw需要关闭窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes 根据窗口大小改变显示大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// make sure the viewport matches the new window dimensions; note that width and</span></span><br><span class="line">	<span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);    <span class="comment">//窗口左下角的坐标x、y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/84675512" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84675512</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>新版OpenGL学习入门（一）——初始化窗口</title>
    <url>/2018/12/01/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>主要用来记录一下学习代码，每次新建一个项目还要配置太麻烦啦</p>
<p>配置网址：<a href="https://blog.csdn.net/qq_19003345/article/details/76098781" target="_blank" rel="noopener">https://blog.csdn.net/qq_19003345/article/details/76098781</a> </p>
<p>学习的是可编辑管线，不过顺便也配置了一下旧版本的，这样可以偶尔运行一下别人的代码</p>
<a id="more"></a>

<p><em>题外话：新版OpenGL比较少，一不小心就找到旧的了。而且和旧版相比，新版需要理解的东西太多了</em></p>
<p>学习网址（这是中文翻译网站）：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/</a></p>
<p>这个代码全部都是原来教程上的，不过加了一点<strong>自己的备注</strong>。建议跟着教程阅读，直接看代码很累。</p>
<blockquote>
<p>Update：如果只是为了写出东西的话，这一块初始化内容完全可以不要去管它</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;      <span class="comment">//窗口回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;  <span class="comment">//输入控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings 初始化设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;     <span class="comment">//初始宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;    <span class="comment">//初始高度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// glfw: initialize and configure   不需要做任何改动</span></span><br><span class="line">	glfwInit();                                             <span class="comment">//初始化GLFW</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);          <span class="comment">//主版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);          <span class="comment">//次版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);   <span class="comment">//核心模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    <span class="comment">// 对于OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw 窗口对象   不需要改动</span></span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">//窗口：宽、高、名称。</span></span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)    <span class="comment">//确保正确创建窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);                                       <span class="comment">//设置窗口上下文为当前线程</span></span><br><span class="line">	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    <span class="comment">//告诉glfw窗口大小会根据改变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glad: load all OpenGL function pointers  加载系统相关的OpenGL函数指针地址的函数   不需要改动</span></span><br><span class="line">	<span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// render loop  渲染循环，这样可以保持一直运行</span></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输入</span></span><br><span class="line">		processInput(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//渲染指令</span></span><br><span class="line">		glClearColor(<span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);    <span class="comment">//设置清空屏幕所用的颜色，每次循环重新渲染，因此需要清空，也因此这是屏幕的背景色。RGB色</span></span><br><span class="line">		glClear(GL_COLOR_BUFFER_BIT);            <span class="comment">//清楚颜色缓冲</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查并调用事件、交换缓冲</span></span><br><span class="line">		glfwSwapBuffers(window);      <span class="comment">//交换颜色缓冲</span></span><br><span class="line">		glfwPollEvents();             <span class="comment">//检查事件触发</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">	glfwTerminate();     <span class="comment">//终止glfw</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)    <span class="comment">//判断是否按下Esc</span></span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);               <span class="comment">//如果时Esc，那么glfw需要关闭窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes 根据窗口大小改变显示大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// make sure the viewport matches the new window dimensions; note that width and</span></span><br><span class="line">	<span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);    <span class="comment">//窗口左下角的坐标x、y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从CSDN搬过来的，原文链接：<a href="https://blog.csdn.net/yueyue200830/article/details/84672369" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84672369</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
</search>
