<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>黑苹果安装记录</title>
    <url>/2020/10/17/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>这是一个小白的黑苹果安装记录，大概花了3天时间搞定了最基本的，作为小白还是选择了clover而不是oc，我的<a href="https://github.com/yueyue200830/ASUS-B360M-8700-EFI" target="_blank" rel="noopener">EFI文件</a></p>
<p>其实到今天要独自装一个黑苹果已经不难了，网上有无数到教程，跟着做就可以了，甚至很多笔记本都有公开到EFI文件，十分方便</p>
<p>此文章没什么干货，仅安装记录，无任何截图，建议点击下面参考教程</p>
<a id="more"></a>
<p>主要参考教程：</p>
<ol>
<li><a href="https://www.sqlsec.com/2020/08/xps15.html#toc-heading-6" target="_blank" rel="noopener">国光大佬xps安装黑苹果</a>，入坑装黑苹果起因也是这篇文章，有黑苹果系统的下载链接（黑果小兵的博客链接找不到正确打开方式。。）</li>
<li><a href="https://www.bilibili.com/video/av28790265" target="_blank" rel="noopener">国光大佬b站黑苹果安装视频</a></li>
<li><a href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" target="_blank" rel="noopener">黑果小兵macOS安装教程兼小米Pro安装过程记录</a></li>
<li><a href="https://www.bilibili.com/video/BV1x54y1X7tS/?spm_id_from=333.788.videocard.9" target="_blank" rel="noopener">2020最新macOS Catalina10.15黑苹果安装教程</a> ，安装工具从这里下载的</li>
</ol>
<h1 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h1><ul>
<li>主板：ASUS B360M-Plus GS</li>
<li>CPU：i7 8700</li>
<li>GPU：uhd 630</li>
<li>SSD：三星830</li>
<li>显示器：dell 2k</li>
<li>系统：Catalina 10.15.7</li>
<li>无蓝牙/wifi</li>
</ul>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>硬件：</p>
<ul>
<li>一块硬盘</li>
<li>一个启动u盘</li>
</ul>
<p>作为从来没试过分区的小白，我选择用一块硬盘作为启动盘，以免影响windows系统，反正台式机有得是地方放硬盘hhh</p>
<p>根据参考教程，<a href="https://mirrors.dtops.cc/iso/MacOS/daliansky_macos/" target="_blank" rel="noopener">下载系统</a>，选择最新的文件<code>macOS Catalina 10.15.7(19H2) Installer for Clover 5122 and WEPE.dmg</code></p>
<p>下载相关软件，上面视频教程有评论链接，我用到了<code>balenaEtcher</code>和<code>DiskGenius</code></p>
<p>在<code>Github</code>上搜索搜索和自己系统对应的EFI文件（比如我的<code>8700 EFI</code>），或者去远景论坛找（但需要买注册码），如果没完全匹配的，可以先用一个相似的配置的EFI</p>
<h1 id="正式流程"><a href="#正式流程" class="headerlink" title="正式流程"></a>正式流程</h1><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>用<code>balenaEtcher</code>把下载好的镜像装入U盘中，详见参考教程1或4</p>
<p>用<code>DiskGenius</code>将符合自己的EFI文件替换原EFI文件（注意：EFI文件的分区在Windows下无法直接显示，必须用软件），详见教程4</p>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>重启电脑，选择U盘作为启动盘，首先选择<code>磁盘工具</code>格式化准备安装的硬盘，然后选择<code>安装Mac OS</code>这个硬盘进行安装，如果安装卡住尝试更换EFI</p>
<p>安装完毕后会自动重启，同样采用U盘作为启动盘，然后会看到启动界面选择<code>boot form &lt;DISK NAME&gt;</code>，如果EFI正常的话就可以进去了</p>
<p>一般来说成功安装系统没那么难，但做到功能完全可以用就相对麻烦</p>
<h2 id="将启动Clover设置为mac所在的盘"><a href="#将启动Clover设置为mac所在的盘" class="headerlink" title="将启动Clover设置为mac所在的盘"></a>将启动Clover设置为mac所在的盘</h2><p>采用<code>DiskGenius</code>或者直接在mac下面用<code>clover</code>挂载u盘和mac所在硬盘的EFI分区，将u盘下面的clover文件夹复制到mac下，在bios下重设启动盘即可</p>
<h2 id="修改为自己电脑的EFI文件"><a href="#修改为自己电脑的EFI文件" class="headerlink" title="修改为自己电脑的EFI文件"></a>修改为自己电脑的EFI文件</h2><p>我找到的EFI文件其实是主板不一致的，也导致了没有正确识别GPU，动画效果明显卡顿，其实clover文件并没有那么复杂，每一块硬件都有自己对应的配置，只要找到满足自己的硬件的EFI，拿过来替换那部分就可以了。<br>比如我主板是<code>ASUS B360M-Plus GS</code>，那么可以搜索一个满足我主板的EFI文件，然后根据网上说的对应部分，修改就好。</p>
]]></content>
  </entry>
  <entry>
    <title>2020秋招总结</title>
    <url>/2020/09/18/2020%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>漫长的秋招从往年的金八银九变成了金七银八，从七月的焦虑到八月初的痛苦到最后的收获，总体我算是幸运的，能拿到几个大厂的意向书。<br>然而反观总体面试情况，其实有点可笑，大厂面的都offer，剩下都不要我。</p>
<a id="more"></a>
<h1 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h1><p>投的后端岗位，略懂前端，各种不精通但Java、Go、C++都有接触，相关项目经验完全不足。<br>有两段外企实习经历，算法在普通人中算不错的。<br>投递基本全为上海的岗位</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>意向书：字节、美团、蚂蚁<br>感谢信：大疆（深圳，笔试挂），京东（二面挂），Akuna（电面挂），商汤（一面挂），Shopee（新加坡，一面挂）<br>无消息：腾讯（只要上海，似乎没hc），亚马逊（学校邮箱没收到笔试邮件）</p>
<p>其实秋招这样的结果也挺无语的，最难进的几个公司给了意向书，剩下一堆都不要我。可能是经验不足吧，大厂不是很在意培养人才，但其它厂比较在意经验（京东二面面试官明确表示我经验不足。。）</p>
<h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p>字节应该是我最幸运的一个公司，也是第一个意向书的公司，收到意向书以后总体就轻松了不少。</p>
<p>因为拿到了字节的实习offer，所以可以直通车，但其实中间过程有点曲折，被打电话后莫名被投到网络工程师然后挂了，去argue后深圳的部门又打电话，之后又变成了上海的视频部门，我选择了放弃面试，再秋招正式批重新申请了。<br>十分意外得是那个部门竟然也给了我直通车的机会，就加了一轮面试，最后给了意向书。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul>
<li>问项目，讲了Go的项目，然后被深入问Go的特点，表示概念只会Java</li>
<li>Java的JVM</li>
<li>段页式存储一次数据查询几次</li>
<li>看我写过vue问js特性</li>
<li>js的promise</li>
<li>计网：如果浏览器页面无法加载怎么排查</li>
<li>算法题：最短包含某个字符串的子串</li>
</ul>
<h1 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h1><p>第一场笔试，编程题AK，本场题目水准不如实习。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>某天晚上的视频面，内容忘得差不多了，没面好</p>
<ul>
<li>hashtable和hashmap区别</li>
<li>第一题算法题应该是dp</li>
<li>后面面试官看我算法不错加了一题：最大回文子串，继续只会dp，O(n)的做法没想出来</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>一二面联系间隔了一整周，差点以为挂了。</p>
<p>本轮面试官思路特别跳跃，一段技术问题，一段闲聊。。。</p>
<ul>
<li>最近看什么书（被我说不看书看博客）</li>
<li>一般看什么博客（遇到问题再看，作死的解答，然后扯到一些和理论不相关但好玩的博客和概念）</li>
<li>java8特性</li>
</ul>
<h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>二面后2小时被hr面了，其实整体感觉有点push。</p>
<p>hr面时说要一个月出结果，然而最终大概一周多就突然收到了意向书</p>
<h1 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h1><p>能拿到蚂蚁的意向书感觉是真的很幸运的，可能所有的坏运气都用在了阿里的笔试上吧，偏偏遇到一场错排+AC自动机的笔试，最后只有0.3，是所有公司笔试中唯一没有AK编程题的笔试。</p>
<p>整体面试效率是很高的，基本间隔两天会有消息。因为当时在实习，每次打电话都约了其它时间，面试官都很nice的同意了。</p>
<h2 id="简历面（一面）"><a href="#简历面（一面）" class="headerlink" title="简历面（一面）"></a>简历面（一面）</h2><p>简历面问的十分基础，因此回答得还不错</p>
<ul>
<li>二叉树，平衡二叉树，红黑树，B+树简单说一下</li>
<li>mysql分页查询</li>
<li>left join， right join</li>
<li>mysql 投影（被坑到了，我只知道英文projection）</li>
<li>数据库锁（乐观锁，悲观锁）</li>
<li>java反射机制，可以干什么</li>
<li>设计模式</li>
<li>IOC</li>
<li>Jvm</li>
<li>文件读取，如果一个比如100G的文件，要做一些处理，怎么设计</li>
<li>排序算法：快排、归并（用法）、桶排</li>
<li>进程和线程</li>
<li>缓存不命中的替换策略</li>
<li>http协议</li>
</ul>
<h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><p>二面就比较深入了，我比较菜，但面试官人也超级好，挑我会的问</p>
<p>主要就问了项目，中间件，还有分布式，然而我并不会分布式，面试官很耐心得引导我怎么设计某个分布式的东西，于是我瞎猜了一通，没想到过了。</p>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>说实话三面面得很不好，疯狂问我实习项目相关的，但我不太能讲清楚（自己觉得讲得还听清楚的呀）</p>
<h2 id="四面（交叉面）"><a href="#四面（交叉面）" class="headerlink" title="四面（交叉面）"></a>四面（交叉面）</h2><p>没想到会有交叉面，但又面得十分糟糕，没有把我项目遇到的问题讲清楚，最后还为了挽回一下我的评级多问了点问题。</p>
<h2 id="HR面-1"><a href="#HR面-1" class="headerlink" title="HR面"></a>HR面</h2><p>阿里的这个hr是我面过最厉害的hr，可以一阵见血得指出我的问题，太太太厉害了。</p>
<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><p>被广东地区部门捞过，表示只要上海的就没后续了</p>
<p>第一轮笔试70分钟AK都没人捞也是很心塞的。</p>
<h1 id="大疆"><a href="#大疆" class="headerlink" title="大疆"></a>大疆</h1><p>随手投了一个没想到C++的岗位，笔试算法AK，概念乱猜，直接感谢信，不过大疆据说今年招的人很少</p>
<h1 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h1><p>笔试算法AK，一面体验很好，二面不行</p>
<h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><p>算是基础面吧，京东的面试还挺固定的，面试前看了面经，Java spring必考，不会就挂，然后疯狂补了一下。</p>
<p>一些小插曲：面试期间腾讯来电话，和面试官说了面试官很nice的说过会儿打回来。</p>
<h2 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h2><p>上来看到我的项目就怼我项目经验不足，就表明不想要我呗，就差没被我怼回去了。。</p>
<p>金融相关部门</p>
<h1 id="Akuna"><a href="#Akuna" class="headerlink" title="Akuna"></a>Akuna</h1><p>唯一一家明知C++还投递的公司，不了解公司业务看着是个外企就投了</p>
<p>笔试是网上做题，有概念和算法，算法题感觉不错，测试点全过了。</p>
<h2 id="电面"><a href="#电面" class="headerlink" title="电面"></a>电面</h2><p>这轮面试说实话是我准备不充分，甚至不太记得C++怎么写。。</p>
<ol>
<li>十六进制的与/或操作</li>
<li>改正一棵树找最大值的函数</li>
<li>实现一个account类，使得可以实想两个帐户之间的转账功能（涉及到锁）</li>
<li>实现STL中的vector（脑子不清晰这题没写出来）</li>
</ol>
<h1 id="商汤"><a href="#商汤" class="headerlink" title="商汤"></a>商汤</h1><p>也是一家随手投，没看清岗位的公司，要求没写清楚要会容器分布式等知识啊。。。</p>
<p>面试时我Java面试官Go，没有什么知识交集。</p>
<h1 id="Shopee"><a href="#Shopee" class="headerlink" title="Shopee"></a>Shopee</h1><p>投的是新加坡的岗，对于中国人开的外国公司体验就一个国内企业的感觉，没有任何外企的感觉。</p>
<p>笔试概念占据超高的比例，算法题超级简单。。</p>
<h2 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h2><p>hr晚上11点给我发面试邀请我就被吓到了。。。</p>
<p>概念部分中规中矩没什么太难的点，算法写hashmap又没认真思考过然后写崩了，还有一题两个栈实现一个队列。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue+Element搭建桌面应用</title>
    <url>/2020/07/24/Vue-Element%E6%90%AD%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>写这篇文章是因为在开发时发现好多文章都过时了（目测我的很快也要过时了）</p>
<p>现在网上大部分以前的文章都是推荐用<code>electron-vue</code>搭建的，但经过我的实验，<code>vue-cli 4.0</code>完全不能用啊，这里推荐一个新的插件<code>Vue CLI Plugin Electron Builder</code>，<a href="https://github.com/nklayman/vue-cli-plugin-electron-builder" target="_blank" rel="noopener">Github</a>，<a href="https://nklayman.github.io/vue-cli-plugin-electron-builder/guide/" target="_blank" rel="noopener">官方文档</a>。</p>
<a id="more"></a>
<p>这个插件使用也十分方便，首先用<code>vue-cli</code>搭建一个<code>Vue</code>的项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装vue-cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用vue-cli搭建一个新的项目，其中会需要一些选项，这里不多介绍，可自行查询</span></span><br><span class="line">vue create &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br></pre></td></tr></table></figure>
<p>之后用添加<code>electron-builder</code>依赖，这里会自动引入<code>Electron</code>，并搭建整个开发环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加electron-builder依赖</span><br><span class="line">vue add electron-builder</span><br><span class="line"></span><br><span class="line"># 安装相关依赖</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"># 运行项目</span><br><span class="line">npm run electron:serve</span><br></pre></td></tr></table></figure>
<p>这里主要是推销一下这个插件，并且帮助大家避雷，就不多介绍其它用法了（本人也是新手）</p>
]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器部署Nginx的坑</title>
    <url>/2020/07/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Nginx%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>好久不发博文了，debug了一天的Nginx部署，必须得记录一下踩过的坑。</p>
<a id="more"></a>
<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>前端有两个页面、后端有一个服务，需要把前端访问转发到后端去读数据库。<br>服务器用的<code>Centos 8</code>。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="问题一：无法转发"><a href="#问题一：无法转发" class="headerlink" title="问题一：无法转发"></a>问题一：无法转发</h2><p>采用<code>proxy_pass</code>转发到local，始终没反应，返回<code>502</code>，log显示<code>(13: Permission denied)</code>，服务器curl localhost有反应。</p>
<p>结果是linux的http设置问题</p>
<p><strong>解决方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect 1</span><br></pre></td></tr></table></figure>
<h2 id="问题二：部分图片加载一半就结束"><a href="#问题二：部分图片加载一半就结束" class="headerlink" title="问题二：部分图片加载一半就结束"></a>问题二：部分图片加载一半就结束</h2><p>有的图片莫名不能加载出来，浏览器的console报错<code>net::ERR_CONTENT_LENGTH_MISMATCH</code>，log显示<code>(13: Permission denied)</code>。</p>
<p>这是真的没权限，因为访问速度较慢，nginx创建了temp文件夹做缓存，结果用户权限不够。</p>
<p><strong>解决方法</strong></p>
<p>在nginx的配置下把user改成root（或者其它有权限访问temp文件夹的用户）</p>
<h2 id="问题三：转发到另一nginx端口无效"><a href="#问题三：转发到另一nginx端口无效" class="headerlink" title="问题三：转发到另一nginx端口无效"></a>问题三：转发到另一nginx端口无效</h2><p>因为有两个前端，设了不同的端口，结果转发失败（后端转发成功），log显示<code>bind() to 0.0.0.0:**** failed</code>。</p>
<p>端口没有注册，需要在系统中加入这个端口。</p>
<p><strong>解决方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo semanage port -a -t http_port_t  -p tcp xxxx <span class="comment"># xxxx is port number</span></span><br></pre></td></tr></table></figure>
<h2 id="问题四：修改文件后无法加载"><a href="#问题四：修改文件后无法加载" class="headerlink" title="问题四：修改文件后无法加载"></a>问题四：修改文件后无法加载</h2><p>把前端的静态文件重新编译部署了以下，就出现了这个问题，返回<code>403</code>，log显示<code>(13: Permission denied)</code>，一直以为是没权限，但用户是root，并且给了777。</p>
<p>结果是nginx的问题，盲猜缓存的锅？</p>
<p><strong>解决方法</strong></p>
<p>手动重新启动，不能用reload</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br><span class="line">nginx -c nginx.conf</span><br></pre></td></tr></table></figure>
<h1 id="崩溃的总结"><a href="#崩溃的总结" class="headerlink" title="崩溃的总结"></a>崩溃的总结</h1><p>linux系统也各种坑呀，一半都是系统设置的问题，一开始还没找到error的log完全不知道发生了什么。</p>
<p>今天以后我也是用过nginx的人了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Deployment</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome浏览器阻止特定URL发送请求</title>
    <url>/2020/05/26/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E9%98%BB%E6%AD%A2%E7%89%B9%E5%AE%9AURL%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>在开发网页又或者做一些其它测试的过程中，有的时候需要block个别URL的请求，网上搜索了一堆，结果发现是超级简单的。。。。</p>
<a id="more"></a>
<p>因为这个操作早在<code>Chrome 59</code>的时候就已经被实现了，只需要在<code>network</code>右键想到block的URL，然后选择<code>Block Request URL</code>即可</p>
<img src="/2020/05/26/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E9%98%BB%E6%AD%A2%E7%89%B9%E5%AE%9AURL%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/block-request-url.png" class="" width="700" title="Block-Request">
<p>之后会跳出一个页面<code>Request blocking</code>，可以设置和查看需要block的网址，并且支持正则表达式</p>
<p>是不是超级方便&amp;简单！！我找了两个小时啊啊啊啊</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于VS Code运行C++中文乱码问题</title>
    <url>/2020/05/26/%E5%85%B3%E4%BA%8EVS-Code%E8%BF%90%E8%A1%8CC-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在几个编辑器里面，VS Code已经算是比较优秀，有插件可以很方便编译和运行<code>c++</code>的，但是因为特殊需要要输出中文，结果发现乱码。。搜索了一通选择了我个人觉得比较方便的方法</p>
<p>这里我编译运行是采用<code>code runner</code>的，但应该对task配置的方法也适用，不过这里强烈推荐<code>code runner</code>！</p>
<a id="more"></a>
<p>首先说说乱码的原因，其实就是<code>cmd</code>和<code>powershell</code>在中文的Windows下默认编码是<code>GBK</code>，而编译输出的文件是<code>UTF-8</code>，于是导致了乱码</p>
<p>其实在<code>git bash</code>里直接运行把编译好的exe是没有编码问题的，不过在VS Code中也似乎变成了<code>GBK</code>的编码</p>
<p>既然是编码问题，那么可以直接把terminal的编码改成<code>UTF-8</code>，这样就可以了。<br>但是搜索了以下， 直接修改会导致一些程序的错误。<br>实际上，我们只是需要运行的环境是<code>UTF-8</code>编码而已，因此只需要命令修改编译运行时的terminal的编码即可。</p>
<p>修改编码的命令是：<code>chcp 65001</code></p>
<p>我们需要将这个命令集成到编译运行的命令里<br>打开用户的<code>setting.json</code>，也可以通过<code>code runner</code>的<code>extention setting</code>中<code>executorMap</code>进入<br>添加以下内容，这里后面的命令是插件自己的命令，没有修改</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"code-runner.executorMap": &#123;</span><br><span class="line">    "cpp": "chcp 65001 &amp;&amp; cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>保存后就会运行这条命令了，可以解决中文乱码的问题</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>通过密钥对服务器进行SSH连接</title>
    <url>/2020/05/24/%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8CSSH%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>常见的ssh连接服务器有两种，一是通过用户名和密码登录，这也是我们最常用的，而另一种是通过密钥来登录，这种不仅可以省去密码，而且更加安全可靠。</p>
<a id="more"></a>
<h1 id="服务器端生成密钥"><a href="#服务器端生成密钥" class="headerlink" title="服务器端生成密钥"></a>服务器端生成密钥</h1><p>首先连接服务器，输入<code>ssh-keygen</code>建立密钥， 会跳出以下内容：（中文备注的地方需要输入处理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ ssh-keygen</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa): &#x2F;&#x2F; 直接按Enter，用默认文件位置</span><br><span class="line">Enter passphrase (empty for no passphrase): &#x2F;&#x2F; 直接Enter，不用密码</span><br><span class="line">Enter same passphrase again: &#x2F;&#x2F; 重复密码</span><br><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|     o +         |</span><br><span class="line">|    o O S .      |</span><br><span class="line">|     X O &#x3D; o     |</span><br><span class="line">|    @ O.* X      |</span><br><span class="line">|   ..XoX.* +     |</span><br><span class="line">|   xxxxxxxx      |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>这样密钥就生成好了，其中<code>id_rsa</code>是密钥，也是我们本地需要的钥匙，<code>id_rsa.pub</code>是公钥，服务器自己持有</p>
<h1 id="服务器配置密钥"><a href="#服务器配置密钥" class="headerlink" title="服务器配置密钥"></a>服务器配置密钥</h1><p>在<code>~/.ssh</code>文件夹下面可以找到刚才生成的钥匙（我这里是root用户，所以上面显示的是<code>/root</code>）</p>
<p>首先需要把<code>id_rsa.pub</code>这个公钥内容复制到<code>authorized_keys</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>
<p>然后需要修改文件的读写权限，保证只有此用户有写权限，一般就设置为以下的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>
<p>到这里如果之前没有对服务器ssh进行修改的话，服务器端配置就完成了</p>
<h1 id="客户端配置密钥"><a href="#客户端配置密钥" class="headerlink" title="客户端配置密钥"></a>客户端配置密钥</h1><p>其实客户端这里没什么配置的，只要把私钥复制到本地就可以</p>
<p>通过<code>scp</code>命令复制id_rsa文件到本地用户的<code>.ssh</code>文件夹下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp root@xxxx:~/.ssh/id_rsa ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>之后就可以通过密钥登录了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@xxx -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下用Python模拟鼠标点击</title>
    <url>/2020/05/19/Windows%E4%B8%8B%E7%94%A8Python%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB/</url>
    <content><![CDATA[<p>由于某些需求，本人被安排了一个实现模拟按键的功能，虽然听说似乎按键精灵也有类似实现，但我的需求可能它无法满足，值得自己写。</p>
<p>对于Windows下的模拟，python一般是采用<code>win32api</code>，此外C++等也可以实现类似的功能，但是python简洁很多，适合不太熟悉Windows变成的人。</p>
<a id="more"></a>
<p>其实一开始是找到一个别人写的项目想直接用的，可惜运行失败，而且有部分需求不满足，有兴趣的可以直接试试<a href="https://github.com/PyUserInput/PyUserInput" target="_blank" rel="noopener">PyUserInput</a></p>
<h1 id="鼠标模拟"><a href="#鼠标模拟" class="headerlink" title="鼠标模拟"></a>鼠标模拟</h1><p>这一块基本和<code>PyUserInput</code>一样，因为我的需求没有那么复杂，所以只用了部分，有兴趣的可以看源码<a href="https://github.com/PyUserInput/PyUserInput/blob/master/pymouse/windows.py" target="_blank" rel="noopener">PyUserInput/pymouse</a></p>
<p>鼠标的基本操作可以分为：press（按下），release（释放），scroll（滚动，这里没写），move（移动）<br>在基本操作的基础上又有：click（按下+释放），drag（按下+移动+释放）</p>
<h2 id="Press-按下"><a href="#Press-按下" class="headerlink" title="Press 按下"></a>Press 按下</h2><p>模拟在屏幕(x, y)的位置下按下鼠标，button=1是左键，button=2是右键</p>
<p>注意这里只模拟了点击操作，并没有修改鼠标的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">press</span><span class="params">(x, y, button=<span class="number">1</span>)</span>:</span></span><br><span class="line">    buttonAction = <span class="number">2</span> ** ((<span class="number">2</span> * button) - <span class="number">1</span>)</span><br><span class="line">    win32api.mouse_event(buttonAction, x, y)</span><br></pre></td></tr></table></figure>
<h2 id="Release-释放"><a href="#Release-释放" class="headerlink" title="Release 释放"></a>Release 释放</h2><p>操作同上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(x, y, button=<span class="number">1</span>)</span>:</span></span><br><span class="line">    buttonAction = <span class="number">2</span> ** ((<span class="number">2</span> * button))</span><br><span class="line">    win32api.mouse_event(buttonAction, x, y)</span><br></pre></td></tr></table></figure>
<h2 id="Move-移动"><a href="#Move-移动" class="headerlink" title="Move 移动"></a>Move 移动</h2><p>这里其实只是将鼠标设定到(x, y)的位置，并没有动画过程（写这个代码想想也没需要吧）</p>
<p>采用了<code>ctypes</code>这个库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    ctypes.windll.user32.SetCursorPos(x, y)</span><br></pre></td></tr></table></figure>
<h2 id="Click-点击"><a href="#Click-点击" class="headerlink" title="Click 点击"></a>Click 点击</h2><p>点击 = 按下 + 释放</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(x, y, button=<span class="number">1</span>)</span>:</span></span><br><span class="line">    press(x, y, button)</span><br><span class="line">    release(x, y, button)</span><br></pre></td></tr></table></figure>
<h2 id="Drag-拖动"><a href="#Drag-拖动" class="headerlink" title="Drag 拖动"></a>Drag 拖动</h2><p>拖动 = 位置1按下 + 位置2释放</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drag</span><span class="params">(x1, y1, x2, y2)</span>:</span></span><br><span class="line">    self.press(x1, y1)</span><br><span class="line">    self.release(x2, y2)</span><br></pre></td></tr></table></figure>
<h2 id="获取当前鼠标位置"><a href="#获取当前鼠标位置" class="headerlink" title="获取当前鼠标位置"></a>获取当前鼠标位置</h2><p>这里其实困扰了我一下，虽然<code>ctypes</code>中有函数可以实现这个功能，但传入的参数有点奇怪，应该是传入的一个指定类型的实例，并且直接将坐标点返回给这个实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(ctypes.Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"x"</span>, ctypes.c_ulong),</span><br><span class="line">                (<span class="string">"y"</span>, ctypes.c_ulong)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pos</span><span class="params">()</span>:</span></span><br><span class="line">    point = Point()</span><br><span class="line">    ctypes.windll.user32.GetCursorPos(ctypes.byref(point))</span><br><span class="line">    <span class="keyword">return</span> point.x, point.y</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/PyUserInput/PyUserInput" target="_blank" rel="noopener">PyUserInput</a></li>
<li><a href="https://github.com/qiueer/autoops_for_win" target="_blank" rel="noopener">autoops_for_win</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown反引号中输入反引号</title>
    <url>/2020/05/18/Markdown%E5%8F%8D%E5%BC%95%E5%8F%B7%E4%B8%AD%E8%BE%93%E5%85%A5%E5%8F%8D%E5%BC%95%E5%8F%B7/</url>
    <content><![CDATA[<p>被上篇文章的代码块中显示反引号坑了好久，不写一下对不起自己啊</p>
<a id="more"></a>
<p>其实超级简单，单行的代码块最外层用两个 <strong>``</strong> 而不是一个 <strong>`</strong></p>
<p><strong>Example</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入&#96;&#96; &#96; &#96;&#96;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<p>输入<code>` </code></p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom安装命令行插件</title>
    <url>/2020/05/18/Atom%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Atom默认是不带终端的，需要安装插件，常见可以在搜索引擎搜索到的有两个：<code>Terminal-Plus</code>和<code>platformio-ide-terminal</code>。<br>而事实上前者是已经放弃更新的插件，后者是基于前者开发的，因此需要安装的是<code>platformio-ide-terminal</code></p>
<a id="more"></a>
<p><strong>注：</strong>Windows系统的我前者安装是直接出错的，完全跳不出，因此必须安装后者！</p>
<h1 id="platformio-ide-terminal安装"><a href="#platformio-ide-terminal安装" class="headerlink" title="platformio-ide-terminal安装"></a>platformio-ide-terminal安装</h1><p>只需要在package中搜索<code>platformio-ide-terminal</code>，点击install就好</p>
<h1 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h1><p>安装好后有三种方法可以打开</p>
<img src="/2020/05/18/Atom%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%92%E4%BB%B6/3.png" class="" title="terminal-powershell">
<h2 id="通过菜单打开terminal"><a href="#通过菜单打开terminal" class="headerlink" title="通过菜单打开terminal"></a>通过菜单打开terminal</h2><p>菜单<code>package</code> → <code>platformio-ide-terminal</code> → <code>Toggle</code></p>
<img src="/2020/05/18/Atom%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%92%E4%BB%B6/1.png" class="" title="menu">
<h2 id="通过小图标打开terminal"><a href="#通过小图标打开terminal" class="headerlink" title="通过小图标打开terminal"></a>通过小图标打开terminal</h2><p>找到左下角中➕的小图标，点击即可</p>
<img src="/2020/05/18/Atom%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%92%E4%BB%B6/2.png" class="" title="icon">
<h2 id="通过快捷键打开terminal"><a href="#通过快捷键打开terminal" class="headerlink" title="通过快捷键打开terminal"></a>通过快捷键打开terminal</h2><p>通过<code>ctrl + ` </code>可以toggle terminal</p>
<p>具体其它快捷键可以参考使用文档，不过我这里似乎new terminal的快捷键被覆盖了</p>
<h1 id="修改默认终端"><a href="#修改默认终端" class="headerlink" title="修改默认终端"></a>修改默认终端</h1><p>Windows下安装好后默认是<code>Powershell</code>，为方便使用，我改成了<code>Git bash</code></p>
<p>在setting中找到platformio-ide-terminal，将其中<code>shell override</code>改为gitbash的路径，我这里是<code>C:\Program Files\Git\bin\bash.exe</code></p>
<img src="/2020/05/18/Atom%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%92%E4%BB%B6/4.png" class="" title="terminal-gitbash">
<p>重新新开一个terminal就可以看到效果了</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Atom</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next添加Valine评论系统</title>
    <url>/2020/05/17/Hexo-Next%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>博客搭建好一段时间了，也终于有空添加上评论，搜了一下常用的评论系统，自己比较喜欢的是<code>Valine</code>和<code>utterances</code>。</p>
<p>而最终选择先搭建Valine完全是因为Valine比较和主题融合（当然后来发现也有些问题），utterances太Github式了，和next不配。</p>
<a id="more"></a>
<p>首先上<code>Valine</code>的<a href="https://valine.js.org" target="_blank" rel="noopener">官方文档页面</a></p>
<h1 id="注册LeanCloud"><a href="#注册LeanCloud" class="headerlink" title="注册LeanCloud"></a>注册LeanCloud</h1><p>Valine的运行是基于<code>LeanCloud</code>的</p>
<p>首先在<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册帐户（表示一开始以为这是外国的，结果发现这个国人的网站，international还没做好)<br>需要验证手机号和邮箱</p>
<p>然后创建应用，其中权限设置可以不用管。</p>
<img src="/2020/05/17/Hexo-Next%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/1.png" class="" width="600" title="Create-Application">
<p>在<code>存储 → 结构化数据</code>中选择<code>创建class</code>，将class名字设为<code>Comment</code>，同样不用管权限。<br>这个<code>Comment</code>就是评论的数据库啦，另外还有一个数据库<code>Counter</code>是用于页面访问统计的<br>ps.似乎不手动创建的话，只要有评论会被自动创建这个class的。</p>
<p>然后在<code>设置 → 应用Keys</code>中找到<code>AppID</code>和<code>AppKey</code></p>
<img src="/2020/05/17/Hexo-Next%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/2.png" class="" title="App-Info">
<h1 id="配置Next"><a href="#配置Next" class="headerlink" title="配置Next"></a>配置Next</h1><blockquote>
<p><strong>注意：</strong>我这里用的是<code>next 7.x</code>，可以直接用valine，较早期版本可能需要安装</p>
</blockquote>
<p>在<code>./themes/next/_config.yml</code>下面搜索<code>valine</code></p>
<p>首先可以找到<code>comments</code>，设置<code>active: valine</code></p>
<p>然后找到<code>valine</code>，把<code>appid</code>和<code>appkey</code>填入，设置<code>enable</code>为<code>true</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># 前面获取的AppID</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment"># 前面获取的AppKey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># 邮件提醒</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># 是否需要验证</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Add</span> <span class="string">your</span> <span class="string">comment</span> <span class="comment"># 输入框默认提示</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,</span> <span class="string">mail,</span> <span class="string">link</span> <span class="comment"># 用户输入的个人信息</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># 文章访问量统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span> <span class="comment"># 是否在首页显示统计页面</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># 是否记录留言IP，只会出现在数据库中</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br></pre></td></tr></table></figure>
<p>这样就可以正常使用valine了。</p>
<h1 id="部分页面关闭评论功能"><a href="#部分页面关闭评论功能" class="headerlink" title="部分页面关闭评论功能"></a>部分页面关闭评论功能</h1><p>打开评论以后是全局都会显示评论的，因此包括<code>tags</code>这种页面也会显示，当然需要关闭评论啦，只需要在头部加上以下内容即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>虽然说整体用起来是很方便的，但是估计之后会换成其它评论，主要一个原因是这个<code>LeanCould</code>其实说不定哪天就收费了，而自己的博客一时半会儿估计也没多少人看，付费是个很不划算的选择。<br>相比之下utterances在Github上集成的，应该会好不少。</p>
<p>第二个原因，也是各种评论系统的一个通病：似乎无法diy界面，这个评论系统的图标和微博一模一样看着不爽啊！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx系统journal日志清理</title>
    <url>/2020/05/15/Liunx%E7%B3%BB%E7%BB%9Fjournal%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>Linux系统下<code>var/log/journal</code>常常霸占着大量空间，但又一般情况毫无用处，因此需要进行一些设定来控制日志大小。</p>
<a id="more"></a>
<p><strong>题外话</strong></p>
<p>作为一个linux小白，也就电脑上装了个虚拟机，20G内存，如果不是写作业把电脑内存用爆了，大概也不会注意到它吧。</p>
<p>我的系统是<code>Ubuntu 18</code>，应该所有linux都适用。</p>
<h1 id="查看占用内存"><a href="#查看占用内存" class="headerlink" title="查看占用内存"></a>查看占用内存</h1><p>处理到<code>var/log/journal</code>下查看内存占用，还可以直接输入以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl --disk-usage</span><br></pre></td></tr></table></figure>
<h1 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h1><h2 id="方法一：通过日志可存在的时间"><a href="#方法一：通过日志可存在的时间" class="headerlink" title="方法一：通过日志可存在的时间"></a>方法一：通过日志可存在的时间</h2><p>通过设置日志可存在的时间长度来删除日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl --rotate</span><br><span class="line">sudo journalctl --vacuum-time=1s</span><br></pre></td></tr></table></figure>
<p><strong>第二行：</strong></p>
<p>这里可选的参数：s是秒，m是分，h是小时，d是日，w是星期，months是月。</p>
<p>因此一般不太可能出现前一秒生成的日志，因此设置时长为1秒可以删除所有日志。<br>但如果之后想保存一段时间的日志，需要重新设置一下，比如我设置为1个月。</p>
<p><strong>第一行：</strong></p>
<p>这里rotate的作用是将一个active的日志变为archived，也就是可能现在在录入日志，把在此之前的日志封装为一个，并换下一个文件进行日志记录。<br>这样可以把在此之前的日志全部清理，当然，不用这个命令也是可以的。</p>
<h2 id="方法二：通过日志可存在的最大内存"><a href="#方法二：通过日志可存在的最大内存" class="headerlink" title="方法二：通过日志可存在的最大内存"></a>方法二：通过日志可存在的最大内存</h2><p>除了用时间，当然也可以用空间来删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl --rotate --vacuum-size=50M</span><br></pre></td></tr></table></figure>
<p>这里是指删除到小于50M，rotate在一些新版本种可以写在一行种。</p>
<p>空间常见的就是KMGT四个单位</p>
<h2 id="方法三：直接删除文件"><a href="#方法三：直接删除文件" class="headerlink" title="方法三：直接删除文件"></a>方法三：直接删除文件</h2><p>把整个文件夹全部删除也是没有问题的，不过我个人觉得有上面的方法为什么还要硬核删除呢。</p>
<h1 id="设置日志参数"><a href="#设置日志参数" class="headerlink" title="设置日志参数"></a>设置日志参数</h1><p>日志文件过大无非是因为没有针对日期和内存大小的自动清理机制，可以通过一些设置来实现。</p>
<p>修改的文件是<code>/etc/systemd/journald.conf</code></p>
<h2 id="设置最大占用空间"><a href="#设置最大占用空间" class="headerlink" title="设置最大占用空间"></a>设置最大占用空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SystemMaxUse=100M</span><br></pre></td></tr></table></figure>
<h2 id="设置最长保存时间"><a href="#设置最长保存时间" class="headerlink" title="设置最长保存时间"></a>设置最长保存时间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MaxFileSec=5day</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.linuxuprising.com/2019/10/how-to-clean-up-systemd-journal-logs.html" target="_blank" rel="noopener">How To Clear The systemd journal Logs</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2020实习申请季</title>
    <url>/2020/04/21/2020%E5%AE%9E%E4%B9%A0%E7%94%B3%E8%AF%B7%E5%AD%A3/</url>
    <content><![CDATA[<p>实习季总算基本告一段落啦，零零碎碎的还有个别面试可能考虑面掉吧，但是已经决定去哪家了。</p>
<p>和其它人相比之下，我算是非大众类型的一类面试者，开始准备已经很晚，基础可以算是烂得一塌糊度，但是算法比较好（高于普通水平，低于acmer）</p>
<a id="more"></a>
<h1 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h1><p>本来去年有在Google实习，基本打算今年继续的，所以其实在三月前是觉得自己很稳的。没有任何复习，还在搞其它的东西。最后也是因为怕万一team match挂可以有个备选吧，结果万万没想到真的备选变成了正选。上周被正式通知取消实习。</p>
<p>正式开始准备（学习）是在三月之后，曾经在3月初还在和同学讨论我是不是该加入复习大军，现在庆幸的是即使线上学习，身边还有一群同学鞭策着自己学习吧。</p>
<p>所有公司除微众银行以外全部投的上海的岗位，投的岗位为SWE/后台开发/Java开发。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>说实话算法我基本没刷过题，除了面微软前补了一周的一年前刷的leetcode，基本就剩下看面经里的算法题了。<br>不过算法不太需要刷也多亏了大一的时候学校自己的oj一共刷了400多道吧，leetcode在大二面试前大概刷了60题，剩下就零零碎碎各个网站了。</p>
<p>因为算是ACM的底子，所以算法题基本是c++，偶尔遇到情况会python，完全不写Java。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>其实算是0基础开始准备的，计网、操作系统特别烂，Java学了几乎等于没学，数据库还在上课。</p>
<p>其实即使到今天，我的基础依旧特别烂，一旦深入就完蛋的那种。<br>如果有能力看源码的确很重要。</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>所有可见的项目都在Github上了，总体就是：没有能被面试的项目。。。</p>
<h2 id="最后成果"><a href="#最后成果" class="headerlink" title="最后成果"></a>最后成果</h2><p>Offer: 微软、字节跳动、摩根士丹利<br>挂过：腾讯腾讯云、阿里CFO、美团、微众银行(没消息)<br>放弃：腾讯正式批、阿里蚂蚁、携程、美团、亚马逊<br>无消息：SAP、Paypal（明确招满了）</p>
<h1 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h1><p>微软是我需要面的公司里最合我的一家吧，算是除Google以外最看重算法最少基础的一家公司。</p>
<p>感觉也算是运气好，我全程算法题，所以还是比较快乐的面试经历。</p>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>我没有参加内推（想到的时候过期的），所以做了笔试，最后的话是0+1+(1-2个测试点)。</p>
<p>第一题花费了很久没看清题意，并且熟悉编译器也花了很久，最后放弃了。<br>第二题虽然听说是去年原题，但我是没有见过啦，不过因为很熟DP，20分钟AC了。<br>第三题忘记是什么题了，最后有两个case没过。</p>
<h2 id="LC1"><a href="#LC1" class="headerlink" title="LC1"></a>LC1</h2><p>我的一面是个女面试官，其实自己表现不算满意，但也其实是觉得面试官没有深究每题？</p>
<p><strong>第一题</strong></p>
<blockquote>
<p>给定一群人，他们可能有些人相互认识，定义只要其中有认识的人就算是一个朋友圈，找到一共有多少个朋友圈。</p>
</blockquote>
<p>我给的解答是DFS，不过面试官问我会不会查并集，实话实说知道但不了解，于是写了DFS的解法。<br>由于写了C++，其实corner case和需要考虑的是比其它语言多的，比如本题我用了引用，但只有部分的引用，被面试官揪出来了。<br>之后写了一些测试用例，并且在面试官的提示下加入了NULL的判断。</p>
<p><strong>第二题</strong></p>
<blockquote>
<p>给定一个数组，两个人玩游戏，只能取左边或者右边，每次都是以最优的方式取的，求第一个取的人是否会赢。</p>
</blockquote>
<p>用的DP解法，面试官理解了很久（我不是很懂这个解法不是一个常见解法之一吗？）<br>继续测试用例，并且用测试用例给面试官解答</p>
<p><strong>一个小题目</strong></p>
<p>最后时间也不是很足了，面试官问了我HashMap的设计，我答了一个基本设计，再加上了一些Java的实现。</p>
<p><strong>提问</strong></p>
<p>问了一下面试官所在的组，写C++和C#多，瞬间觉得应该用python写算法题的。。</p>
<h2 id="LC2"><a href="#LC2" class="headerlink" title="LC2"></a>LC2</h2><p>这个面试官就问了一道题，个人觉得做得还行，但逻辑不够清晰</p>
<p><strong>题目</strong></p>
<blockquote>
<p>给定一个四则运算的字符串输入，求出结果</p>
</blockquote>
<p>记忆中曾经好像见过类似的，用的是栈？但没想出来，最后很复杂的用了很多变量做的，白板代码又是讲解了半天的逻辑。<br>面试官没让我写判断输入是否合法，但直接讲了不合法的情况，然后就被C++坑了呀，没考虑到输入长度超出int类型的情况（我爱python）</p>
<h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><p>唔，这是一场神奇的面试，主要奇怪在后半部分。</p>
<p>首先面试官让我讲一下之前的算法题，然后再二面的题目上加上了括号，说一下怎么做，我做了一个懒惰的修改版，直接递归。<br>然后分享屏幕，用IDE做了一题，可以编译（人好啊）。至于面试题，我想不起来了，本地代码被我删除了。。。不过很简单就是了，最多十几分钟写完的</p>
<p><strong>然后</strong>，30分钟面完了，面试官为了撑时间和我闲聊，甚至推荐我转行投行、PE和咨询赚钱。面完觉得要挂了。。。</p>
<h1 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h1><p>申请的是AI Lab的后端实习，当初纯粹是想挑个冷门的部门试试，但现在感觉正式员工还是可能其它部门比较好？<br>和大部分部门不太一样的是，AI Lab只有两面，超级快乐！</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>基础基本不记得问了什么，但没什么难点是肯定的。</p>
<p>由于有前端经历，被面试官问了一个js的闭包，没复习不会，不过用var声明题目看起来有点历史悠久呀。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">　　name : <span class="string">"My Object"</span>,</span><br><span class="line">　　getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>算法题一</strong></p>
<blockquote>
<p>给一棵完全二叉树，计算它的节点个数</p>
</blockquote>
<p>一开始完全没看倒完全二叉树，所以用了全搜索的解法，后来提醒之下说了一个其实没问题但比较复杂然而面试官并没有懂的解法，时间复杂度和面试官的解法一样。</p>
<p><strong>算法题二</strong></p>
<blockquote>
<p>Leetcode原题：Partition Equal Subset Sum</p>
</blockquote>
<p>见过，不记得是否做过，题目看错，最后发现dp，五分钟秒的，但因为写了优化版的面试官没看懂，又两分钟极限写代码证明自己是对的。</p>
<p><strong>总结</strong>：面试官不是算法好的人，脑子一般般，优化dp这么基础的看不懂，建议多刷点题。</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>周日面试面试官还因为开会迟到，好忙呀。</p>
<p>此面没问基础，问了项目，但也不深挖。</p>
<p><strong>算法题一</strong></p>
<blockquote>
<p>给n*m的矩阵，正整数，假设为小岛，如果某个点大于它相邻的点，那么就说河水可以流下去，这个矩阵外面是海水，最旁边的点河水可以流到海里，找出不能流到海里的点</p>
</blockquote>
<p>基础dfs，挺简单的</p>
<p><strong>算法题二</strong></p>
<blockquote>
<p>给1-n的，输出字典序</p>
</blockquote>
<p>据说leetcode原题，没见过，一开始没注意到是1-n，字典树都出来了，后来反应过来很简单，递归。结果写得太快被反问是不是做过？？没见我题目都没看清嘛。</p>
<h2 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h2><p>用的zoom，谈了20分钟，主要也就是读不读研，怎么选择offer。个人感觉表现一般，最后联系我给offer的也是这个hr了。</p>
<h1 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h1><p>美团hr真的是史上最垃圾hr，但是面试官人真的好好！</p>
<p>当初没了解过部门，投的是基础研发，感觉比较偏？面的部门是搞数据库的</p>
<h2 id="笔试-1"><a href="#笔试-1" class="headerlink" title="笔试"></a>笔试</h2><p>1+1+0.45+0+0.45<br>算是一个还行但也不太好的成绩吧，不过喜欢美团的题目，最算法的一个。</p>
<h2 id="一面（电面）"><a href="#一面（电面）" class="headerlink" title="一面（电面）"></a>一面（电面）</h2><p>这个面试官人超级好！不会的就说没关系，还是唯一一个挖我的blog的面试官。</p>
<ul>
<li>讲一下项目（挖坑j2ee自己跳下去了）</li>
<li>你是java比较熟吗（项目java，算法c++，python也还行）</li>
<li>前端使用js？（不太熟，用过）</li>
<li>问linux，$0,$1,$?,$$是什么（记忆中回答了$0和$1是第一个和第二个参数）</li>
<li>然后提到了我的blog，于是问怎么修改ssh端口（我的博文，但是不记得了）</li>
<li>Linux常用命令</li>
<li>服务器部署了什么（提到项目and我的乱七八糟的小东西）</li>
<li>假设项目部署在服务器，并且又访问日志，如果用linux命令获取最常访问的ip（说了map，用linux命令不会）</li>
<li>硬链接\&amp;软链接（不记得）</li>
<li>数据库存储引擎（innodb，还有一个不记得）</li>
<li>数据库事务</li>
<li>隔离级别</li>
<li>数据库int(11)和int(10)有区别吗？范围一样吗（猜的有，不一样）</li>
<li>数据库表里的数据被清掉一半，但磁盘没释放，为什么？（不会）</li>
<li>七层模型and常用协议</li>
<li>http code</li>
<li>三次握手四次挥手</li>
<li>Js的apply和call区别（没听说过，懵逼）</li>
<li>跨域（没回答好，说一般在java配置）面试官表示jsonp可用解决</li>
<li>Vue监听属性的变化（不太知道，猜了个onChange，顺便我问投的后端啊）</li>
<li>Jsp和servlet有什么区别（表示一起用的呀，不知道）面试官说：同一个。。。</li>
<li>算法题：ip转成int再转回ip</li>
<li>设计lru（没答好，我说了一个方法，让再想一个，表示感觉没法优化了。。）</li>
<li>假设有人用脚本访问你的项目，如何限制访问（一开始说java，后来说nginx，然后才知道要数据库。。。主要说法就是map记录次数），升级版是分布式，再说如果访问量更大呢（猜了一个redis）</li>
<li>介绍团队</li>
<li>反问怎么了解前端</li>
<li>又问了我blog打cf，我就趁机表示了一下最近没怎么刷题，后来想拿cf练练手。</li>
</ul>
<h2 id="二面（电面）"><a href="#二面（电面）" class="headerlink" title="二面（电面）"></a>二面（电面）</h2><p>优秀的一面面试官，面完10分钟给我约了二面！<br>二面感觉自己面得很糟糕</p>
<p><em>有空补，可能是个坑</em></p>
<h2 id="hr面-1"><a href="#hr面-1" class="headerlink" title="hr面"></a>hr面</h2><p>天真以为oc原来这是面试呀，说考虑一下，反手被挂</p>
<h2 id="加面一"><a href="#加面一" class="headerlink" title="加面一"></a>加面一</h2><p>被同一个事业群不同部门捞起，加面一轮视频面试。结果因为自己的简历的锅来了一个c++面试官，知识交集约为0。。。</p>
<ul>
<li>首先讲了一下技术栈，然后表示用java，c++只会写题。</li>
<li>讲一下hashmap，被我又扯到java</li>
<li>跳表会吗（不会，讲道理不是学过数据结构会调表，而是学过redis会跳表啊）</li>
<li>网络和多线程哪块好一些？表示多线程会java，但没写过大的，网络以为是计网，结果是网络编程？不会，然后扯了一些计网和抓包</li>
</ul>
<p><strong>算法题</strong></p>
<blockquote>
<p>将单链表的每K个节点之间逆序</p>
</blockquote>
<p>题目见过没写过，问了面试官同意到自己的本地ide debug，最后不是那么好的做完了。</p>
<h2 id="加面二"><a href="#加面二" class="headerlink" title="加面二"></a>加面二</h2><p>加面完大概半小时多被打电话约加面，估计是换一个java面试官来吧。<br>由于那几天有点忙，往后约了两天，然后拿到其它offer就放弃面试了。</p>
<h1 id="摩根士丹利"><a href="#摩根士丹利" class="headerlink" title="摩根士丹利"></a>摩根士丹利</h1><p>摩根的笔试和微软冲突了，于是没在第一批笔试。<br>今年笔试相比往年简单了不少，2道算法题很简单，5道选择卡了一下。</p>
<h2 id="电面"><a href="#电面" class="headerlink" title="电面"></a>电面</h2><p>这是一个神奇的电面，面试内容都是我没见过的</p>
<ul>
<li>讲一下排序算法有哪些，介绍了快排和归并的思想</li>
<li>api全称叫什么</li>
<li>uml全称，了解uml吗，项目中有用过uml吗，对uml的感觉是什么（喜欢或不喜欢）</li>
<li>了解ddos吗</li>
<li>什么是事务</li>
<li>一开始说错了，提到ACID，讲一下acid</li>
<li>如果单线程单服务器，还要事务吗</li>
<li>你有用过junit，那么知道如果模拟数据库吗（不记得了，说用的mockito）</li>
</ul>
<h2 id="算法面"><a href="#算法面" class="headerlink" title="算法面"></a>算法面</h2><p>这一面被气到了，如果不是面试官找不到我的帐户，大概我不用写那个非算法题吧。<br>作为半个acmer，我很能分别算法题和代码题，显然，我运气不好得碰到代码题。</p>
<p>事情就是面试官找不到我的帐户，第一次面试，于是给我出了一个题目，分享屏幕，用本地ide写代码。</p>
<p>题目是约瑟夫环，但是条件限制还挺多的。<br>已经不记得算法版怎么做的了，于是做了链表版的，手写无法编译，肉眼debug，写了一堆问题，一般链表默认单链表啊，我写完告诉我可以双链表，行吧。。</p>
<p>面试体验-10</p>
<h2 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h2><p>没问语言相关，问了数据库（join，primary key \&amp; foreign key）和网络（三次握手，还有提到对称加密非对称加密）其余不记得，不难。</p>
<h2 id="半hr面"><a href="#半hr面" class="headerlink" title="半hr面"></a>半hr面</h2><p>我开启了随意聊天模式，感觉没问太多有效信息，反而被我各种反问hhhh</p>
<h1 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h1><p>说真的，作为一个内部自信到要死认为别人都不如自己的大厂，为什么还要发那么多广告。好感度-100</p>
<h2 id="笔试-2"><a href="#笔试-2" class="headerlink" title="笔试"></a>笔试</h2><p>唔，运气好像还行，1+0.65，那个没全过的c++估计被卡精度了，python被卡超时了。。。</p>
<h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><p>投的是一个CFO部门，然而因为阿里一面是我第一个面试的公司，所以各种不会，各种紧张，面得超级烂。<br>基本就是问我什么都说不太清楚，java熟悉哪块我都不熟悉。</p>
<p>由于面得太糟糕不愿意去听录音。不过没想到还捞我二面。。。</p>
<h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><ul>
<li>常见网络协议有哪些</li>
<li>网络协议分几层，各有什么协议</li>
<li>为什么要分这么多层（最后被我扯到耦合性去了。。。）</li>
<li>一般防火墙在哪层（一开始猜了，后来说不知道）</li>
<li>负载均衡在哪一层（网络/应用都可以）</li>
<li>http和https区别</li>
<li>https的安全机制大概逻辑（我讲了非对称加密）</li>
<li>线程vs进程</li>
<li>Linux命令看进程/线程运行（ps，我说能看进程，线程不知道）</li>
<li>Top命令中load和cpu使用率的区别（不知道）</li>
<li>浏览器中网址过程</li>
<li>（问题有点绕）最后就是关于cookie和session</li>
<li>不同服务器如何判别同一个cookie/session（感觉这里一开始面试官说cookie，后来说了session，我回答了session）</li>
<li>二级域名的cookie，三级域名有吗，（猜有）其它网站有吗（没）</li>
<li>设计模式（讲工厂讲得特别混乱。。）</li>
<li>对称加密vs非对称加密</li>
<li>讲一下hashmap，线程安全吗，哪里会线程不安全</li>
<li>讲一下奖项。。。然后讲题（我说讲一下最近的cf一道题，但是讲得比较混乱。。因为牵涉到数学）</li>
<li>讲实习，学到了什么</li>
</ul>
<p>面完被打电话问是否愿意转测试（不愿意），之后发现没消息，后来牛客上看了一下这个部门应该招满了，而且自己也的确面得不好。</p>
<h2 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h2><p>又找了蚂蚁捞的我，大概是一面和简历面混合版吧，主问项目，面得不好。</p>
<ul>
<li>设计一个购物系统</li>
<li>cookie和session</li>
</ul>
<h2 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h2><p>还是被约了二面，拿到其它offer放弃了。</p>
<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><p>说说腾讯的情况，因为主Java，不想去c++，所以先投web开发，再换了客户端。</p>
<h2 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h2><p>投完第二天早上被微信捞了，晚上面试，然而表示不愿去广东，就聊了一下。<br>前端基本不会，表示想去web后端。</p>
<h2 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h2><p>被腾讯云的IOS捞了，表示没基础。</p>
<p>其实一面的基础面得超级烂，主要是考os相关的了，没太复习。<br>被问了堆和栈的区别，我回答了java版的，和os的不太一样。。。面试官应该没get<br>算法题似乎是反转链表。</p>
<h2 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h2><p>就算是压力面也不用这样怼我吧，全程怼项目，后来想想应该怼回去的。<br>我就随口问了一句你们加班吗，被反问你为什么觉得不加班。难道不是传闻有些部门不怎么加班嘛，我问一句还不行吗。</p>
<p>代码题：写单例</p>
<p><strong>结果</strong>：当然挂了</p>
<h1 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h1><p>这家在我心中二线公司也是挺有趣的，估计因为今年国外很多offer被revoke了，很多人回来找实习也投了携程保底，他们竟然自信到把之前说好的不用笔试的同学们拉去笔试，还把一个拿到阿里offer的同学笔试给刷了。</p>
<h2 id="笔试-3"><a href="#笔试-3" class="headerlink" title="笔试"></a>笔试</h2><p>算法部分：83+75+100，选择部分随便选。<br>不算特别高，但感觉够分数线就交卷了，事实证明还是排在很前面的，基本和提前批的一个时间面试的。</p>
<h2 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h2><p>记忆中基础没怎么问，而且问的也很浅。</p>
<p><strong>代码题一</strong></p>
<blockquote>
<p>判断两个二叉树是否相等</p>
</blockquote>
<p><strong>代码题二</strong></p>
<blockquote>
<p>写个堆的push</p>
</blockquote>
<p>基本就没碰过堆，忘记了方法，还好被提醒了一下，就会写了</p>
<h2 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h2><p>这个面试官特别迷，各个概念块一个个问下来，包括队列和栈、排序算法、数据库等都挺简单而且非常浅的，最后写了一个工厂模式。</p>
<h1 id="Amazon"><a href="#Amazon" class="headerlink" title="Amazon"></a>Amazon</h1><p>神奇的亚马逊发邮件投递，一个月后应该是第二批被捞，发我邮件约时间，结果给的时间段过了还没给我面试时间，在过两天又一个面试邮件来，由于拿到offer回复邮件放弃了，然而hr没看到邮件还被面试官打电话了。。不太行。。</p>
<h1 id="微众银行"><a href="#微众银行" class="headerlink" title="微众银行"></a>微众银行</h1><p>这家算保底的保底了，就做了一个笔试题，30min秒完AK交卷，估计是我选择题太差了没收到面试通知（真的不看一下我编程做了多久吗？？？）<br>不过反正保底的保底不给我面试我也不稀罕</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Internship</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode——142. Linked List Cycle II</title>
    <url>/2020/04/08/Leetcode%E2%80%94%E2%80%94142-Linked-List-Cycle-II/</url>
    <content><![CDATA[<p>刷题时看到这道题，看了解答觉得很数学\&amp;有趣，就来写个数学证明题吧hhhh</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
</blockquote>
<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Leetcode链接</a></p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>其实这是<code>Linked List Cycle</code>的升级版，和1一样，首先判断是否成环，采用快慢指针的方法，这里就不多加解释。</p>
<p>当我们确定是成环时，我们需要去寻找环的头部。</p>
<h2 id="解法一：map记录"><a href="#解法一：map记录" class="headerlink" title="解法一：map记录"></a>解法一：map记录</h2><p>这是一个最简单的方法就是用map记录环中的点，然后从头开始找第一个在map中的点，这里我也就不放代码了。</p>
<p>时间复杂度$O(n)$，但空间复杂度有点高。。</p>
<h2 id="解法二：双指针寻找-数学原理）"><a href="#解法二：双指针寻找-数学原理）" class="headerlink" title="解法二：双指针寻找(数学原理）"></a>解法二：双指针寻找(数学原理）</h2><p>这是我想记录的一个方法，个人认为没见过解答一般没法想出来，倒是可能猜到？</p>
<p><strong>做法</strong>：假设前面快慢指针分别为a和b，现在a和b应指向同一个节点，只需选择其中一个（如a）与一个新的指向头部head的节点的指针c一起往前走，它们第一次指向的同一个节点就是环的第一个节点。</p>
<p>简单来说写个伪代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a is a previous pointer</span></span><br><span class="line">c = head;</span><br><span class="line"><span class="keyword">while</span> (a != c) &#123;</span><br><span class="line">  a = a-&gt;next;</span><br><span class="line">  c = c-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是很神奇？完全想不到啊</p>
<p>时间复杂度$O(n)$，空间复杂度$O(1)$。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>首先，定义这里的长度为需要走的步数。</p>
<p>假设从head到环的头部的长度为$S<em>{head}$，环的长度为$S</em>{circle}$。<br>在前面的算法，慢指针a走了$S_a$，快指针b走了$S_b$。<br>则我们有</p>
<script type="math/tex; mode=display">S_b = 2 * S_a</script><p>又因为现在a和b在同一个点，因此b比a多走$k$圈，即</p>
<script type="math/tex; mode=display">S_b - S_a = k * S_{circle}</script><script type="math/tex; mode=display">S_a = k * S_{circle}</script><p>那么若a又走了$S_1$的长度的话（即从头走到环头部的长度）</p>
<script type="math/tex; mode=display">S_a' = S_{head} + S_a</script><script type="math/tex; mode=display">S_a' = S_{head} + k * S_{circle}</script><p>这就正好是走了一个头部到环的距离+$k$圈环，也就是a正好在环的头部。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *a = head;</span><br><span class="line">    ListNode *b = head;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">NULL</span> &amp;&amp; b != <span class="literal">NULL</span> &amp;&amp; b-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span> || b-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    b = head;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现Canny算子边缘检测</title>
    <url>/2020/04/04/Python%E5%AE%9E%E7%8E%B0Canny%E7%AE%97%E5%AD%90%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>Canny边缘检测算子是John F.Canny于1986年开发出来的一个多级边缘检测算法。Canny的目标是找到一个最优的边缘检测算法。</p>
<p>这里附上我手写的代码，不保证有bug。这里图像偷懒直接裁剪而没有做padding。以及代码大多没用numpy写，所以运行速度较慢（实际就是不会）</p>
<a id="more"></a>
<p>其三个主要评价标准：</p>
<ol>
<li>低错误率: 标识出尽可能多的实际边缘，同时尽可能的减少噪声产生的误报。</li>
<li>高定位性: 标识出的边缘要与图像中的实际边缘尽可能接近。</li>
<li>最小响应: 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。</li>
</ol>
<p>Canny算子求边缘点具体算法步骤如下：</p>
<h1 id="1-用高斯滤波器平滑图像"><a href="#1-用高斯滤波器平滑图像" class="headerlink" title="1. 用高斯滤波器平滑图像"></a>1. 用高斯滤波器平滑图像</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>高斯滤波器（kernel）是将高斯函数离散化，将滤波器中对应的横纵坐标索引代入高斯函数，即可得到对应的值。</p>
<p>(2k+1)x(2k+1) 滤波器的计算公式如下：</p>
<script type="math/tex; mode=display">H[i, j] = \frac{1}{2 \pi \sigma ^ 2} e ^ {- \frac{(i-k-1)^2 + (j-k-1)^2}{2 \sigma ^ 2}}</script><p>常见的高斯滤波器为size=5，其近似值为：</p>
<script type="math/tex; mode=display">
K = \frac{1}{159}
\left[
 \begin{matrix}
   2 & 4 & 5 & 4 & 2 \\\\
   4 & 9 & 12 & 9 & 4 \\\\
   5 & 12 & 15 & 12 & 5 \\\\
   4 & 9 & 12 & 9 & 4 \\\\
   2 & 4 & 5 & 4 & 2
  \end{matrix}
\right]</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码首先根据length和σ计算出高斯滤波器，然后对图片进行平滑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smooth</span><span class="params">(image, sigma = <span class="number">1.4</span>, length = <span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="comment"># Compute gaussian filter</span></span><br><span class="line">    k = length // <span class="number">2</span></span><br><span class="line">    gaussian = np.zeros([length, length])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">            gaussian[i, j] = np.exp(-((i-k) ** <span class="number">2</span> + (j-k) ** <span class="number">2</span>) / (<span class="number">2</span> * sigma ** <span class="number">2</span>))</span><br><span class="line">    gaussian /= <span class="number">2</span> * np.pi * sigma ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># Batch Normalization</span></span><br><span class="line">    gaussian = gaussian / np.sum(gaussian)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use Gaussian Filter</span></span><br><span class="line">    W, H = image.shape</span><br><span class="line">    new_image = np.zeros([W - k * <span class="number">2</span>, H - k * <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(W - <span class="number">2</span> * k):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(H - <span class="number">2</span> * k):</span><br><span class="line">            new_image[i, j] = np.sum(image[i:i+length, j:j+length] * gaussian)</span><br><span class="line"></span><br><span class="line">    new_image = np.uint8(new_image)</span><br></pre></td></tr></table></figure>
<h1 id="2-计算梯度幅值和方向"><a href="#2-计算梯度幅值和方向" class="headerlink" title="2. 计算梯度幅值和方向"></a>2. 计算梯度幅值和方向</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>常见方法采用Sobel滤波器在计算梯度和方向。</p>
<p>采用以下卷积阵列计算x和y的差分：</p>
<script type="math/tex; mode=display">
G_x =
\left[
 \begin{matrix}
   -1 & 0 & +1  \\\\
   -2 & 0 & +2  \\\\
   -1 & 0 & +1  \\\\
  \end{matrix}
\right]</script><script type="math/tex; mode=display">
G_y =
\left[
 \begin{matrix}
   -1 & -2 & -1  \\\\
    0 &  0 &  0  \\\\
   +1 & +2 & +1  \\\\
  \end{matrix}
\right]</script><p>采用下列公式计算梯度幅值和方向：</p>
<script type="math/tex; mode=display">
G = \sqrt{(G_x^2 + G_y^2)}</script><script type="math/tex; mode=display">
\theta = \arctan{\frac{G_y}{G_x}}</script><p>梯度角度θ范围从弧度-π到π，然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°）。可以以 $±\frac{iπ}{8}$（i=1,3,5,7）分割，落在每个区域的梯度角给一个特定值，代表四个方向之一。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gradient_and_direction</span><span class="params">(image)</span>:</span></span><br><span class="line">    Gx = np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">    Gy = np.array([[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    W, H = image.shape</span><br><span class="line">    gradients = np.zeros([W - <span class="number">2</span>, H - <span class="number">2</span>])</span><br><span class="line">    direction = np.zeros([W - <span class="number">2</span>, H - <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(W - <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(H - <span class="number">2</span>):</span><br><span class="line">            dx = np.sum(image[i:i+<span class="number">3</span>, j:j+<span class="number">3</span>] * Gx)</span><br><span class="line">            dy = np.sum(image[i:i+<span class="number">3</span>, j:j+<span class="number">3</span>] * Gy)</span><br><span class="line">            gradients[i, j] = np.sqrt(dx ** <span class="number">2</span> + dy ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> dx == <span class="number">0</span>:</span><br><span class="line">                direction[i, j] = np.pi / <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direction[i, j] = np.arctan(dy / dx)</span><br><span class="line"></span><br><span class="line">    gradients = np.uint8(gradients)</span><br></pre></td></tr></table></figure>
<h1 id="3-对梯度幅值进行非极大值抑制"><a href="#3-对梯度幅值进行非极大值抑制" class="headerlink" title="3. 对梯度幅值进行非极大值抑制"></a>3. 对梯度幅值进行非极大值抑制</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>非极大值抑制是进行边缘检测的一个重要步骤，通俗意义上是指寻找像素点局部最大值。沿着梯度方向，比较它前面和后面的梯度值，如果它不是局部最大值，则去除。</p>
<p>这里借用知乎@戴馨乐的图片，由于图片是之前记录下的，原文地址没有保存</p>
<img src="/2020/04/04/Python%E5%AE%9E%E7%8E%B0Canny%E7%AE%97%E5%AD%90%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/1.jpg" class="" title="非极大值抑制">
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NMS</span><span class="params">(gradients, direction)</span>:</span></span><br><span class="line">    W, H = gradients.shape</span><br><span class="line">    nms = np.copy(gradients[<span class="number">1</span>:<span class="number">-1</span>, <span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, W - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, H - <span class="number">1</span>):</span><br><span class="line">            theta = direction[i, j]</span><br><span class="line">            weight = np.tan(theta)</span><br><span class="line">            <span class="keyword">if</span> theta &gt; np.pi / <span class="number">4</span>:</span><br><span class="line">                d1 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">                weight = <span class="number">1</span> / weight</span><br><span class="line">            <span class="keyword">elif</span> theta &gt;= <span class="number">0</span>:</span><br><span class="line">                d1 = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> theta &gt;= - np.pi / <span class="number">4</span>:</span><br><span class="line">                d1 = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">                weight *= <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d1 = [<span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">                weight = <span class="number">-1</span> / weight</span><br><span class="line"></span><br><span class="line">            g1 = gradients[i + d1[<span class="number">0</span>], j + d1[<span class="number">1</span>]]</span><br><span class="line">            g2 = gradients[i + d2[<span class="number">0</span>], j + d2[<span class="number">1</span>]]</span><br><span class="line">            g3 = gradients[i - d1[<span class="number">0</span>], j - d1[<span class="number">1</span>]]</span><br><span class="line">            g4 = gradients[i - d2[<span class="number">0</span>], j - d2[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">            grade_count1 = g1 * weight + g2 * (<span class="number">1</span> - weight)</span><br><span class="line">            grade_count2 = g3 * weight + g4 * (<span class="number">1</span> - weight)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grade_count1 &gt; gradients[i, j] <span class="keyword">or</span> grade_count2 &gt; gradients[i, j]:</span><br><span class="line">                nms[i - <span class="number">1</span>, j - <span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="4-用双阈值算法检测"><a href="#4-用双阈值算法检测" class="headerlink" title="4. 用双阈值算法检测"></a>4. 用双阈值算法检测</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>设置两个阈值，minVal和maxVal。梯度大于maxVal的任何边缘是真边缘，而minVal以下的边缘是非边缘。位于这两个阈值之间的边缘会基于其连通性而分类为边缘或非边缘，如果它们连接到“可靠边缘”像素，则它们被视为边缘的一部分；否则，不是边缘。</p>
<p>这里采用dfs搜索的方法，对于所有真边缘开始dfs搜索，直至搜索完成。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_threshold</span><span class="params">(nms, threshold1, threshold2)</span>:</span></span><br><span class="line">    visited = np.zeros_like(nms)</span><br><span class="line">    output_image = nms.copy()</span><br><span class="line">    W, H = output_image.shape</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= W <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= H <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> visited[i, j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        visited[i, j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> output_image[i, j] &gt; threshold1:</span><br><span class="line">            output_image[i, j] = <span class="number">255</span></span><br><span class="line">            dfs(i<span class="number">-1</span>, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i<span class="number">-1</span>, j)</span><br><span class="line">            dfs(i<span class="number">-1</span>, j+<span class="number">1</span>)</span><br><span class="line">            dfs(i, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i, j+<span class="number">1</span>)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output_image[i, j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> range(W):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(H):</span><br><span class="line">            <span class="keyword">if</span> visited[w, h] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> output_image[w, h] &gt;= threshold2:</span><br><span class="line">                dfs(w, h)</span><br><span class="line">            <span class="keyword">elif</span> output_image[w, h] &lt;= threshold1:</span><br><span class="line">                output_image[w, h] = <span class="number">0</span></span><br><span class="line">                visited[w, h] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> range(W):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(H):</span><br><span class="line">            <span class="keyword">if</span> visited[w, h] == <span class="number">0</span>:</span><br><span class="line">                output_image[w, h] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="OpenCV自带函数"><a href="#OpenCV自带函数" class="headerlink" title="OpenCV自带函数"></a>OpenCV自带函数</h1><p>OpenCV有自带函数可以进行高斯平滑和canny算子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = cv2.GaussianBlur(image, (<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">canny = cv2.Canny(image, <span class="number">50</span>, <span class="number">160</span>)</span><br></pre></td></tr></table></figure>
<h1 id="全部手写代码"><a href="#全部手写代码" class="headerlink" title="全部手写代码"></a>全部手写代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smooth</span><span class="params">(image, sigma = <span class="number">1.4</span>, length = <span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Smooth the image</span></span><br><span class="line"><span class="string">    Compute a gaussian filter with sigma = sigma and kernal_length = length.</span></span><br><span class="line"><span class="string">    Each element in the kernal can be computed as below:</span></span><br><span class="line"><span class="string">        G[i, j] = (1/(2*pi*sigma**2))*exp(-((i-k-1)**2 + (j-k-1)**2)/2*sigma**2)</span></span><br><span class="line"><span class="string">    Then, use the gaussian filter to smooth the input image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        image: array of grey image</span></span><br><span class="line"><span class="string">        sigma: the sigma of gaussian filter, default to be 1.4</span></span><br><span class="line"><span class="string">        length: the kernal length, default to be 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        the smoothed image</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Compute gaussian filter</span></span><br><span class="line">    k = length // <span class="number">2</span></span><br><span class="line">    gaussian = np.zeros([length, length])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">            gaussian[i, j] = np.exp(-((i-k) ** <span class="number">2</span> + (j-k) ** <span class="number">2</span>) / (<span class="number">2</span> * sigma ** <span class="number">2</span>))</span><br><span class="line">    gaussian /= <span class="number">2</span> * np.pi * sigma ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># Batch Normalization</span></span><br><span class="line">    gaussian = gaussian / np.sum(gaussian)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use Gaussian Filter</span></span><br><span class="line">    W, H = image.shape</span><br><span class="line">    new_image = np.zeros([W - k * <span class="number">2</span>, H - k * <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(W - <span class="number">2</span> * k):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(H - <span class="number">2</span> * k):</span><br><span class="line">            new_image[i, j] = np.sum(image[i:i+length, j:j+length] * gaussian)</span><br><span class="line"></span><br><span class="line">    new_image = np.uint8(new_image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gradient_and_direction</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">""" Compute gradients and its direction</span></span><br><span class="line"><span class="string">    Use Sobel filter to compute gradients and direction.</span></span><br><span class="line"><span class="string">         -1 0 1        -1 -2 -1</span></span><br><span class="line"><span class="string">    Gx = -2 0 2   Gy =  0  0  0</span></span><br><span class="line"><span class="string">         -1 0 1         1  2  1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        image: array of grey image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        gradients: the gradients of each pixel</span></span><br><span class="line"><span class="string">        direction: the direction of the gradients of each pixel</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    Gx = np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">    Gy = np.array([[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    W, H = image.shape</span><br><span class="line">    gradients = np.zeros([W - <span class="number">2</span>, H - <span class="number">2</span>])</span><br><span class="line">    direction = np.zeros([W - <span class="number">2</span>, H - <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(W - <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(H - <span class="number">2</span>):</span><br><span class="line">            dx = np.sum(image[i:i+<span class="number">3</span>, j:j+<span class="number">3</span>] * Gx)</span><br><span class="line">            dy = np.sum(image[i:i+<span class="number">3</span>, j:j+<span class="number">3</span>] * Gy)</span><br><span class="line">            gradients[i, j] = np.sqrt(dx ** <span class="number">2</span> + dy ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> dx == <span class="number">0</span>:</span><br><span class="line">                direction[i, j] = np.pi / <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direction[i, j] = np.arctan(dy / dx)</span><br><span class="line"></span><br><span class="line">    gradients = np.uint8(gradients)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gradients, direction</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NMS</span><span class="params">(gradients, direction)</span>:</span></span><br><span class="line">    <span class="string">""" Non-maxima suppression</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        gradients: the gradients of each pixel</span></span><br><span class="line"><span class="string">        direction: the direction of the gradients of each pixel</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        the output image</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    W, H = gradients.shape</span><br><span class="line">    nms = np.copy(gradients[<span class="number">1</span>:<span class="number">-1</span>, <span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, W - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, H - <span class="number">1</span>):</span><br><span class="line">            theta = direction[i, j]</span><br><span class="line">            weight = np.tan(theta)</span><br><span class="line">            <span class="keyword">if</span> theta &gt; np.pi / <span class="number">4</span>:</span><br><span class="line">                d1 = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">                weight = <span class="number">1</span> / weight</span><br><span class="line">            <span class="keyword">elif</span> theta &gt;= <span class="number">0</span>:</span><br><span class="line">                d1 = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> theta &gt;= - np.pi / <span class="number">4</span>:</span><br><span class="line">                d1 = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">                weight *= <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d1 = [<span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line">                d2 = [<span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">                weight = <span class="number">-1</span> / weight</span><br><span class="line"></span><br><span class="line">            g1 = gradients[i + d1[<span class="number">0</span>], j + d1[<span class="number">1</span>]]</span><br><span class="line">            g2 = gradients[i + d2[<span class="number">0</span>], j + d2[<span class="number">1</span>]]</span><br><span class="line">            g3 = gradients[i - d1[<span class="number">0</span>], j - d1[<span class="number">1</span>]]</span><br><span class="line">            g4 = gradients[i - d2[<span class="number">0</span>], j - d2[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">            grade_count1 = g1 * weight + g2 * (<span class="number">1</span> - weight)</span><br><span class="line">            grade_count2 = g3 * weight + g4 * (<span class="number">1</span> - weight)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grade_count1 &gt; gradients[i, j] <span class="keyword">or</span> grade_count2 &gt; gradients[i, j]:</span><br><span class="line">                nms[i - <span class="number">1</span>, j - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_threshold</span><span class="params">(nms, threshold1, threshold2)</span>:</span></span><br><span class="line">    <span class="string">""" Double Threshold</span></span><br><span class="line"><span class="string">    Use two thresholds to compute the edge.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        nms: the input image</span></span><br><span class="line"><span class="string">        threshold1: the low threshold</span></span><br><span class="line"><span class="string">        threshold2: the high threshold</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        The binary image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    visited = np.zeros_like(nms)</span><br><span class="line">    output_image = nms.copy()</span><br><span class="line">    W, H = output_image.shape</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= W <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= H <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> visited[i, j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        visited[i, j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> output_image[i, j] &gt; threshold1:</span><br><span class="line">            output_image[i, j] = <span class="number">255</span></span><br><span class="line">            dfs(i<span class="number">-1</span>, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i<span class="number">-1</span>, j)</span><br><span class="line">            dfs(i<span class="number">-1</span>, j+<span class="number">1</span>)</span><br><span class="line">            dfs(i, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i, j+<span class="number">1</span>)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j<span class="number">-1</span>)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            dfs(i+<span class="number">1</span>, j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output_image[i, j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> range(W):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(H):</span><br><span class="line">            <span class="keyword">if</span> visited[w, h] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> output_image[w, h] &gt;= threshold2:</span><br><span class="line">                dfs(w, h)</span><br><span class="line">            <span class="keyword">elif</span> output_image[w, h] &lt;= threshold1:</span><br><span class="line">                output_image[w, h] = <span class="number">0</span></span><br><span class="line">                visited[w, h] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> range(W):</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(H):</span><br><span class="line">            <span class="keyword">if</span> visited[w, h] == <span class="number">0</span>:</span><br><span class="line">                output_image[w, h] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># code to read image</span></span><br><span class="line">    smoothed_image = smooth(image)</span><br><span class="line">    gradients, direction = get_gradient_and_direction(smoothed_image)</span><br><span class="line">    nms = NMS(gradients, direction)</span><br><span class="line">    output_image = double_threshold(nms, <span class="number">40</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><img src="/2020/04/04/Python%E5%AE%9E%E7%8E%B0Canny%E7%AE%97%E5%AD%90%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.png" class="" title="输出">
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows修改右键新建菜单</title>
    <url>/2020/03/15/Windows%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<p>由于课程需求被强制安装了国际知名建模软件EA然而本人真的一点都不喜欢，并且被此软件搞得太不爽了，课程结束删除软件发现竟然没有把右键新建里一起删除，太令人崩溃了吧。。。</p>
<p>在网上搜索解决方案不知道为何失败后，决定试一下自己修改，没想到成功了！！</p>
<p>方法依旧是修改<code>注册表</code>，只是修改不同的部分。</p>
<a id="more"></a>
<h1 id="打开注册表"><a href="#打开注册表" class="headerlink" title="打开注册表"></a>打开注册表</h1><p>Windows 10下直接搜索<code>注册表</code>可以跳出来<code>注册表编辑器</code>直接打开即可（搜索多优秀呀，何必学习网上教程注册表编辑器的英文打开方式呢）</p>
<img src="/2020/03/15/Windows%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95/1.png" class="" width="700" title="搜索注册表">
<h1 id="新建文件的存储位置（常规方法）"><a href="#新建文件的存储位置（常规方法）" class="headerlink" title="新建文件的存储位置（常规方法）"></a>新建文件的存储位置（常规方法）</h1><p>右键新建文件的位置是在：<code>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Discardable\PostSetup\ShellNew</code><br>双击打开后有一个<code>Classes</code>，可以看到数据那栏是一堆文件的后缀名</p>
<img src="/2020/03/15/Windows%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95/2.png" class="" width="700" title="“新建”位置">
<p>双击<code>Classes</code>，可以对数据进行编辑，添加或删除不要的后缀名</p>
<img src="/2020/03/15/Windows%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95/3.png" class="" width="700" title="修改新建数据">
<p><strong>然而</strong>，我并没有成功修改。。。每次删除后又被加回来了。。。<br>一开始以为中病毒了呢。。。<br>而事实上是因为只删除了部分导致注册表错误。。。</p>
<h1 id="删除文件后缀关联"><a href="#删除文件后缀关联" class="headerlink" title="删除文件后缀关联"></a>删除文件后缀关联</h1><p>打开<code>计算机\HKEY_CURRENT_USER</code>，可以看到里面有各式各样的后缀（以<code>.</code>开头的）</p>
<img src="/2020/03/15/Windows%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95/4.png" class="" title="后缀">
<p>那既然上个方法删不掉我们想要的，不如看看这个后缀文件的注册表里有些什么东西。</p>
<p>找到需要删除的文件后缀对应的文件夹，比如我要删除<code>.eap</code></p>
<img src="/2020/03/15/Windows%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AE%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95/5.png" class="" width="700" title="后缀文件夹">
<p>我们可以看到怎么里面有一个<code>ShellNew</code>？？？这不是和前面那个新建文件的名字一样吗？？？<br>再打开其它的后缀文件夹看一下，果然没有<code>ShellNew</code><br>那大概可以猜到是<code>ShellNew</code>的锅，这边定义了有新增但我们上面那个方法只是删除了一个地方，导致出错了。</p>
<p>因此<strong>解决方法</strong>就是把<code>ShellNew</code>删除掉，由于我本来把软件也卸载了，就直接整个后缀的文件夹全删光了（个人猜测是那个公司写的垃圾）<br>删除后关闭就可以发现新建菜单里没有啦！</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title>Python读取图片并保存的几种方式</title>
    <url>/2020/03/11/Python%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E4%BF%9D%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>这里尝试过<code>png</code>和<code>jpg</code>，为方便保存路径在函数内自动转换，因此需要路径后缀恰为三位。</p>
<a id="more"></a>
<h1 id="方法一：Pillow"><a href="#方法一：Pillow" class="headerlink" title="方法一：Pillow"></a>方法一：Pillow</h1><p>这里采用<code>pillow</code>读取图片，它默认显示图片采用系统的默认图片显示器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image_1</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">""" Pillow</span></span><br><span class="line"><span class="string">    This will show picture with default image showing program.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: path of the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image = Image.open(path)</span><br><span class="line">    image.show()</span><br><span class="line">    new_path = path[:<span class="number">-4</span>] + <span class="string">'-fc1.jpg'</span></span><br><span class="line">    image.save(new_path)</span><br></pre></td></tr></table></figure>
<h1 id="方法二：Matplot"><a href="#方法二：Matplot" class="headerlink" title="方法二：Matplot"></a>方法二：Matplot</h1><p>这里用<code>matplot</code>的<code>pyplot</code>去读取和显示图片，注意保存图片需要在显示之前执行，否则无法保存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image_2</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">""" matplot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: path of the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image = mpimg.imread(path)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    new_path = path[:<span class="number">-4</span>] + <span class="string">'-fc2.jpg'</span></span><br><span class="line">    mpimg.imsave(new_path, image)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="方法三：OpenCV"><a href="#方法三：OpenCV" class="headerlink" title="方法三：OpenCV"></a>方法三：OpenCV</h1><p>这里显示图片需要条用<code>cv2.waitKey()</code>，否则图片会显示后立刻消失。</p>
<p><strong>注意</strong>：OpenCV读取的图片的排列方式为bgr而非常见的rgb</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image_3</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">""" OpenCV</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: path of the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image = cv2.imread(path)</span><br><span class="line">    cv2.imshow(path, image)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    new_path = path[:<span class="number">-4</span>] + <span class="string">'-fc3.jpg'</span></span><br><span class="line">    cv2.imwrite(new_path, image)</span><br></pre></td></tr></table></figure>
<h1 id="方法四：Imageio"><a href="#方法四：Imageio" class="headerlink" title="方法四：Imageio"></a>方法四：Imageio</h1><p>这里<code>imageio</code>只是用于读取和保存，用<code>matplot</code>显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image_4</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">""" imageio</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: path of the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image = imageio.imread(path)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.show()</span><br><span class="line">    new_path = path[:<span class="number">-4</span>] + <span class="string">'-fc4.jpg'</span></span><br><span class="line">    imageio.imsave(new_path, image)</span><br></pre></td></tr></table></figure>
<h1 id="方法五：skimage"><a href="#方法五：skimage" class="headerlink" title="方法五：skimage"></a>方法五：skimage</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image_5</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">""" skimage</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: path of the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image = io.imread(path)</span><br><span class="line">    io.imshow(image)</span><br><span class="line">    new_path = path[:<span class="number">-4</span>] + <span class="string">'-fc5.jpg'</span></span><br><span class="line">    io.imsave(new_path, image)</span><br><span class="line">    io.show()</span><br></pre></td></tr></table></figure>
<h1 id="相关加载库"><a href="#相关加载库" class="headerlink" title="相关加载库"></a>相关加载库</h1><p>以防万一不知道import什么，这里列一下需要import的库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> imageio</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装MySQL8.0</title>
    <url>/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/</url>
    <content><![CDATA[<p>安装环境为<code>Ubuntu 18.04.4 LTS</code>。<br>由于在<code>apt</code>下默认的版本是<code>mysql5.7</code>，需要先配置仓库，再进行安装。</p>
<a id="more"></a>
<h1 id="添加MySQL8-0仓库"><a href="#添加MySQL8-0仓库" class="headerlink" title="添加MySQL8.0仓库"></a>添加MySQL8.0仓库</h1><p>首先在<a href="https://dev.mysql.com/downloads/file/?id=494003" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=494003</a>下载<code>apt repository</code></p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/3.png" class="" width="800">
<p>然后配置仓库，输入：（其中PATH和deb的名称应根据自己的需求更改，可参照下面截图的头部）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i /PATH/version-specific-package-name.deb</span><br></pre></td></tr></table></figure>
<p>然后会跳出来仓库配置界面，直接选择ok</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/5.png" class="" width="700">
<p>接着更新仓库，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>可以看到在更新的仓库中已有<code>MySQL</code></p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/7.jpg" class="" width="700">
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><p>在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>在输入安装命令并下载完成后，即进入配置模式。<br>在弹出的框内输入root用户的密码或先设为空，然后再次确认密码</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/9.png" class="" width="700">
<p>在选择验证方式时，选择第一个推荐的（网上有说这个对Ubuntu18.04不支持，但是经实验应该已修复此问题）</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/10.png" class="" width="700">
<h1 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h1><p>采用之前配置的密码进入mysql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>可以看到版本号和其它一些信息，证明安装正确</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/12.png" class="" width="700">
<h1 id="查看MySQL启动信息"><a href="#查看MySQL启动信息" class="headerlink" title="查看MySQL启动信息"></a>查看MySQL启动信息</h1><p>输入命令查看MySQL的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql status</span><br></pre></td></tr></table></figure>
<p>可以看到之前安装完成并且首次启动MySQL时已开启MySQL</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/13.png" class="" width="800">
<p>尝试停止MySQL服务：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure></p>
<h1 id="设置默认mysql命令参数"><a href="#设置默认mysql命令参数" class="headerlink" title="设置默认mysql命令参数"></a>设置默认mysql命令参数</h1><p>在当前用户的用户目录下新建<code>.my.cnf</code>，可配置如用户名/密码等，来简便mysql的操作</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/17.png" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">host&#x3D;localhost</span><br><span class="line">user&#x3D;root</span><br><span class="line">password&#x3D;&lt;password&gt;</span><br></pre></td></tr></table></figure>
<p>这样只需输入<code>mysql</code>即可以root用户进入数据库</p>
<img src="/2020/03/09/Ubuntu%E5%AE%89%E8%A3%85MySQL8-0/16.png" class="" width="700">
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces——1322B.Present</title>
    <url>/2020/03/08/Codeforces%E2%80%94%E2%80%941322B-Present/</url>
    <content><![CDATA[<p>下定决心开始打CF的第一个比赛就被虐得好惨，还需要继续努力啊（虽然感觉CF和面试算法题关系不大。。）</p>
<p>题目网址： <a href="https://codeforces.com/contest/1322/problem/B" target="_blank" rel="noopener">https://codeforces.com/contest/1322/problem/B</a></p>
<p>好吧，事实上写这篇博文是因为第一次遇到这个解法，对于我这个算法小白来说还是很新颖的。<br>PS.做题的时候天真的以为是O(n)的解法，并且可以用数学做。。。</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定$n$个数 $a_1$, $a_2$, … , $a_n$，<br>计算其两两之和的异或值。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先输入大小以看就不可以直接求（废话）<br>复杂度也就是压在O(nlogn)左右</p>
<p><strong>关键点</strong><br>我们可以把答案回到二进制，然后对二进制的每一位分开求。</p>
<p><strong>原理</strong></p>
<p>首先我们定义 $x_i = a_k + a_j$， 即 $x_i$ 是两数之和。<br>令 $s$ 是答案，$s_i$ 是指从右往左答案的第 $i$ 个二进制位（从0开始）</p>
<p>我们现在假设计算 $s_i$，我们已知所有 $x$ 的第 $i$ 位的01情况，那么求 $s_i$ 就是对它们做异或，也就等于计算 $x$ 中第 $i$ 位是1的个数的奇偶情况。<br>即如果1有偶数个，那么答案对应的位数是0，反之则是1。（简单的异或运算原理）</p>
<h2 id="Subproblem"><a href="#Subproblem" class="headerlink" title="Subproblem"></a>Subproblem</h2><blockquote>
<p>对于结果$s$，计算第 $i$ 位的值，即 $s_i$。</p>
<p>（等价问题）计算两数之和$x$的第 $i$ 位是 $1$ 的数量。</p>
</blockquote>
<p>对于这个等价问题，我们先思考一个简单的情况：</p>
<p>假设现在有一个数 $y &lt; 2^{i+1}$，它的第$i$位的是否位$1$取决于它是否在 $[2^{i}, 2^{i+1})$ 内。<br>现在把 $y$ 扩大为正数，我们可以得到其第$i$位的情况与 $y’ = y \% 2^{i+1} $。</p>
<p>因此，对于每个 $x$，我们可以只考虑 $x \% 2^{i+1} $。</p>
<p>但我们希望能通过 $a$ 直接计算出个数，而非计算 $x$ 后求出解。<br>既然我们可以对 $x$ 取模，自然也可以对 $a$ 取模，这对加法并不会有影响。</p>
<p>因此，我们首先将 $a$ 对 $2^{i+1}$ 取模，令取模后的数为 $b$。<br>我们可以得到 $b \in [0, 2^{i+1} )$，<br>即有 $x \in [0, 2^{i+2}-1 )$。</p>
<p>我们发现 $x$ 的范围缩小了很多，这次我们不对 $x$ 取模，<br>相反，我们可以直接对 $x$ 划出两个范围：$[2^i, 2^{i+1})$ 和 $[2^i + 2^{i+1}, 2^{i+2}-1 )$</p>
<p>因此，我们希望寻找 $x$ 在这两个范围内的个数</p>
<h2 id="Subsubproblem"><a href="#Subsubproblem" class="headerlink" title="Subsubproblem"></a>Subsubproblem</h2><blockquote>
<p>对于结果 $s$ 的第 $i$ 位，现有 $b$ 是对 $a$ 对于 $2^{i+1}$ 取模，求 $b$ 两两之和在 $[2^i, 2^{i+1})$ 和 $[2^i + 2^{i+1}, 2^{i+2}-1 )$ 的个数。</p>
<p>（简化版）给定数组 $b$，求其两两和在某一区间的个数。</p>
</blockquote>
<p>这里为简化，假设求的区间是 $[k, t)$</p>
<p><em>暂时只有 $O(nlogn)$ 的解法，未知是否有更迅速的</em></p>
<p>首先将 $b$ 从小到大排序，<br>然后对 $b<em>i$ ，它可以相加的数为 $b</em>{i+1}$, …, $b_n$ 。<br>用二分查找寻找下界值为 $k-b_i$ 的下标 $p$，<br>用二分查找寻找上界值为 $t-b_i$ 的下标 $q$。<br>满足的个数就是 $q-p$。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">400005</span>], b[<span class="number">400005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, i, j, k, t, m, p, q, s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        m = <span class="built_in">max</span>(a[i], m);</span><br><span class="line">    &#125;</span><br><span class="line">    m = log2(m) + <span class="number">2</span>;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        k = <span class="built_in">pow</span>(<span class="number">2</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            b[j] = a[j] % k;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b, b+n);</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 2^i, 2^(i+1)</span></span><br><span class="line">            p = lower_bound(b+j+<span class="number">1</span>, b+n, k/<span class="number">2</span> - b[j]) - b;</span><br><span class="line">            q = lower_bound(b+j+<span class="number">1</span>, b+n, k - b[j]) - b;</span><br><span class="line">            t += q - p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2^i + 2^(i+1), 2^(i+2)-1</span></span><br><span class="line">            p = lower_bound(b+j+<span class="number">1</span>, b+n, k/<span class="number">2</span>*<span class="number">3</span> - b[j]) - b;</span><br><span class="line">            q = lower_bound(b+j+<span class="number">1</span>, b+n, <span class="number">2</span>*k - <span class="number">1</span>) - b;</span><br><span class="line">            t += q - p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            s += k / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Codeforces</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Termux - Android terminal</title>
    <url>/2020/03/07/Termux-Android-terminal/</url>
    <content><![CDATA[<p>此处留个坑，纪念一下终于安装了<code>Termux</code>，并且可以使用啦。<br>不过怕自己<code>rm -rf</code>一键把手机给挂了，没怎么配权限 &amp; 在备用机上安装的。<br>希望有空更新并且学习一下。</p>
<a id="more"></a>
<p>记录几个不错的学习网址：</p>
<p><a href="http://www.huangpan.net/posts/ji-ke/2019-08-19-termux.html#" target="_blank" rel="noopener">Termux 学习笔记</a><br><a href="https://www.sqlsec.com/2018/05/termux.html#" target="_blank" rel="noopener">Termux 高级终端安装使用配置教程</a><br><a href="https://wiki.termux.com/wiki/Main_Page" target="_blank" rel="noopener">官方Wiki</a></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>Termux</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统下对文件进行MD5校验</title>
    <url>/2020/03/04/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CMD5%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>MD5全称MD5信息摘要算法（MD5 Message-Digest Algorithm），是一种被广泛使用的密码散列函数，用于确保信息传输完整一致。</p>
</blockquote>
<p>如今，MD5虽然被证明安全性不足，但被广泛运用于文件的校验上。<br>当下载较大文件时，为避免数据缺损，可以进行MD5校验。当然也可以运用于第三方下载官方文件的校验（尤其国内下外网速度不够的情况）</p>
<a id="more"></a>
<p>本来以为Windows下属性里面会有的，作为一个小白发现想多了，并没有。<br>于是以为要下载软件，没先到其实Windows是有内嵌命令行工具<code>CertUtil</code>的。</p>
<p><strong>命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certutil -hashfile filePath [HashAlgorithm]</span><br></pre></td></tr></table></figure>
<p>这里<code>filePath</code>就是文件路径，可用绝对路径或相对路径</p>
<p><code>HashAlgorithm</code>可以是<code>MD2</code>、<code>MD4</code>、<code>MD5</code>、<code>SHA1</code>、<code>SHA256</code>、<code>SHA384</code>、<code>SHA512</code></p>
<p><strong>样例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certutil -hashfile C:\file.exe MD5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title>新版Windows Terminal</title>
    <url>/2020/02/29/%E6%96%B0%E7%89%88Windows-Terminal/</url>
    <content><![CDATA[<p>微软在19年的时候宣布开发新的Windows Terminal，虽然这仅仅是一个终端，并非开发一个新的shell，但是新版整合了各种shell并且超级好看！！<br>这个终端的优点是可以打开各种不同的shell，比如<code>cmd</code>、<code>PowerShell</code>、<code>Azure</code>、<code>GitBash</code>等。</p>
<a id="more"></a>
<p>截图：<br><img src="/2020/02/29/%E6%96%B0%E7%89%88Windows-Terminal/terminal.png" class="" width="700" title="Terminal"></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>微软在<a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener">Github</a>上公开了代码，可以有两种方法安装，一个是用VS，还有就是直接应用商店下载</p>
<p>只是想玩一下的我当然应用商店下载啦，又方便又不容易又bug，就是更新慢点而已</p>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>在微软应用商店搜索<code>Windows Terminal</code>，可以找到以下内容，安装即可</p>
<img src="/2020/02/29/%E6%96%B0%E7%89%88Windows-Terminal/store.png" class="" width="700" title="Store">
<h1 id="使用与配置"><a href="#使用与配置" class="headerlink" title="使用与配置"></a>使用与配置</h1><p>安装好后可以直接打开，会发现emmm没有什么好看的，当然主要的大招是自己配置哈哈哈</p>
<p>找到下拉菜单，可以发现应该有cmd、PowserShell和Azure，选择<code>setting</code>，用文本编辑器打开，这是一个<code>json</code>的配置文件</p>
<h2 id="增加亚力克（Acrylic）效果"><a href="#增加亚力克（Acrylic）效果" class="headerlink" title="增加亚力克（Acrylic）效果"></a>增加亚力克（Acrylic）效果</h2><p>在每个shell的配置文件中添加：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"useAcrylic": true</span><br></pre></td></tr></table></figure></p>
<p>保存重新打开就可以看到之前本文的截图效果了（也就是毛玻璃），瞬间爱了呀！<br>然而鸡肋的cmd并没有因此有改进。。。只是界面影响心情所以喜欢了哈哈哈</p>
<h2 id="切换默认shell"><a href="#切换默认shell" class="headerlink" title="切换默认shell"></a>切换默认shell</h2><p>安装打开后默认应该是PowerShell，由于不用PowerShell，所以把它改成了cmd</p>
<p>找到<code>defaultProfile</code>，把它的内容改成你想到修改的shell对应的<code>guid</code></p>
<p>比如我的cmd配置如下：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make changes here to the cmd.exe profile</span></span><br><span class="line">    <span class="attr">"guid"</span>: <span class="string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"cmd"</span>,</span><br><span class="line">    <span class="attr">"commandline"</span>: <span class="string">"cmd.exe"</span>,</span><br><span class="line">    <span class="attr">"hidden"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"useAcrylic"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么defaultProfile就改为：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"defaultProfile": "&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span><br></pre></td></tr></table></figure></p>
<h2 id="添加gitbash"><a href="#添加gitbash" class="headerlink" title="添加gitbash"></a>添加gitbash</h2><p>配置如下，复制进去基本就可以<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Git Bash</span></span><br><span class="line">    <span class="attr">"guid"</span>: <span class="string">"&#123;00000000-0000-0000-ba54-000000000002&#125;"</span>,</span><br><span class="line">    <span class="attr">"closeOnExit"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"colorScheme"</span> : <span class="string">"Campbell"</span>,</span><br><span class="line">    <span class="attr">"commandline"</span> : <span class="string">"\"%PROGRAMFILES%\\git\\usr\\bin\\bash.exe\" -i -l"</span>,</span><br><span class="line">    <span class="attr">"cursorColor"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">    <span class="attr">"cursorShape"</span> : <span class="string">"bar"</span>,</span><br><span class="line">    <span class="attr">"historySize"</span> : <span class="number">9001</span>,</span><br><span class="line">    <span class="attr">"icon"</span> : <span class="string">"%PROGRAMFILES%\\Git\\mingw64\\share\\git\\git-for-windows.ico"</span>,</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Git Bash"</span>,</span><br><span class="line">    <span class="attr">"snapOnInput"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"startingDirectory"</span> : <span class="string">"%USERPROFILE%"</span>,</span><br><span class="line">    <span class="attr">"useAcrylic"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于icon，我自己的是mitty的gitbash，所以有以上位置，但如果用的cmd的，icon应该位置不太一样，这里没有去搜过，如果跳不出来可以去搜索或者直接自己硬找一下</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>其实写这篇博文主要还是脑子一抽觉得new Windows Terminal真的好好看呀，但是其实并不怎么使用它。。。<br>毕竟习惯性打开cmd或者右键gitbash了</p>
<p>但是组合在一起其实使用起来还是比较方便的，并且比较好看的界面+好看的字体+支持windows表情还是很不错的。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Google Play Store一直「正在等待下载」的问题</title>
    <url>/2020/02/29/%E8%A7%A3%E5%86%B3Google-Play-Store%E4%B8%80%E7%9B%B4%E3%80%8C%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>大概月初开始，我的小米的Play Store就开始卡在<code>正在等待下载</code>，play store其它内容加载一切正常，其它网页加载也都正常，但是就是无法更新。。<br>卡了近一个月后终于想到网络搜索解决问题了。</p>
<a id="more"></a>
<ol>
<li>确保是软件问题，play store可加载其它内容，且没有程序卡在<code>正在下载</code></li>
<li>打开play store的应用信息，选择<code>清楚全部数据</code>，可能会出现提示，按确定清除数据<img src="/2020/02/29/%E8%A7%A3%E5%86%B3Google-Play-Store%E4%B8%80%E7%9B%B4%E3%80%8C%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98/play-store.jpg" class="" width="300" title="Play-store"></li>
<li>【小米手机/部分国内手机】打开<code>下载管理</code>（或类似名称），禁用迅雷加速下载<img src="/2020/02/29/%E8%A7%A3%E5%86%B3Google-Play-Store%E4%B8%80%E7%9B%B4%E3%80%8C%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98/xunlei.jpg" class="" width="300" title="Xunlei"></li>
<li>打开下载管理的应用信息，选择<code>清楚全部数据</code></li>
<li>重新打开play store，查看是否恢复正常</li>
</ol>
<p>完全不懂什么原理，个人猜测线程卡死死锁了？<br>据说play store的下载机制是通过手机自己的下载来下载的，所以可能出奇奇怪怪的问题。。</p>
<p>ps. play store绝对是一个神奇的软件，在我的三星出现了一个更迷的bug，无法自动更新play store，永远显示已经最新版，且确定过版本应该不是盗版。。。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo多终端同步及发布至Github</title>
    <url>/2020/02/24/Hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E5%8F%8A%E5%8F%91%E5%B8%83%E8%87%B3Github/</url>
    <content><![CDATA[<p>因为有两台电脑的关系，很多东西都需要同步，一般文件比较小的会用<code>Onedrive</code>，文件比较大的比如Hexo会选择用<code>GitHub</code>（主要贫穷的我只有5G的免费空间）。<br>相比于其它普通文件夹直接push就可以同步，这个就稍微麻烦一点，因为整个文件夹里有多个含有git的文件夹。<br>而在第一次直接把跟目录push上去以后，甚至遇到了这个网站<code>yueyue200830.github.io</code>的github全部被覆盖。<br>当时整个人内心都十分崩溃。。。</p>
<a id="more"></a>
<h1 id="解决方法之概念"><a href="#解决方法之概念" class="headerlink" title="解决方法之概念"></a>解决方法之概念</h1><p>首先，我们需要了解一下hexo是如何push到github上的</p>
<p>在根目录寻找一圈后，会发现有一个<code>.deploy_git</code>的文件夹，打开发现和github上面的文件完全一样。<br>没错了，hexo就是直接编译在这个文件夹生成文件，然后push到github上面。</p>
<p>然而，不要高兴太早，如果单纯的push为什么换电脑是覆盖而不是有任何的conflict信息呢？</p>
<p>在<code>.deploy_git</code>文件夹在打开<code>git bash</code>，输入<code>git remote -v</code>，发现竟然什么也没有？？？</p>
<p>介于自己完全不熟练<code>git</code>命令，打开了外部有同步的文件夹同样输入<code>git remote -v</code>，是会得到以下显示的<br><img src="/2020/02/24/Hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E5%8F%8A%E5%8F%91%E5%B8%83%E8%87%B3Github/gitbash1.png" class="" title="Screenshot1"></p>
<p>虽然不清楚发生了什么（对不起，我就是一个git小白）。。但是可以知道我们git仓库没有github上面的信息<br>也就是每次hexo在deploy的时候，是直接把整个仓库替换上去的（好粗暴呀。。）</p>
<p>而再去看一下整个项目的github，发面默认的gitignore里把<code>.deploy_git</code>添加上了。<br>也就是说同步的时候根本没有任何之前发布的信息，所以当换了一台电脑的时候就会遇到如此崩溃的事情了。</p>
<h1 id="解决方法之实际操作"><a href="#解决方法之实际操作" class="headerlink" title="解决方法之实际操作"></a>解决方法之实际操作</h1><p>既然<code>.deploy_git</code>和项目各会同步在我的github上，那么与其取消ignore，不如在<code>.deploy_git</code>上添加远程仓库，每次更新前做一个同步。</p>
<p>在<code>.deploy_git</code>文件夹的终端下输入以下内容，让其连接到github仓库（注意在最后加上<code>.git</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/yueyue200830/yueyue200830.github.io.git</span><br></pre></td></tr></table></figure>
<p>这个时候，我们再输入<code>git remote -v</code>，可以看到有信息了</p>
<p>再把remote和本地的进行一次同步：（应该用pull也可以）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就在本地同步与github同步成功了，只需要再另一台电脑上也进行以下同步配置，之后每次换电脑的时候只需要两个文件夹各同步一下就可以啦。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>多终端</tag>
      </tags>
  </entry>
  <entry>
    <title>Github加速访问/防DNS污染</title>
    <url>/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/</url>
    <content><![CDATA[<p>在访问DNS有的时候会比较慢甚至无法打开，而我最近遇到的一个问题是DNS被污染，并且由于同时加载了境内和境外DNS，根本无法找到究竟是哪里受到了DNS污染。为此我搜了不少资料，最终得到了以下的解决方案，不过其实这个方法个人认为也是治标不治本。</p>
<p>解决方法就是本地设置<code>hosts</code>/<code>DNS</code>，强制直接让网站访问某个ip从而跳过寻找ip地址。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>简单讲一下原理（应该其实会一点CS的都懂啦），可以跳过。</p>
<p>在访问网站时，由于我们输入的是域名（如<code>www.google.com</code>)，需要寻找它真实的ip地址再去访问。<br>那如何获取它的ip地址呢，这就是DNS和hosts的用处了。</p>
<p>电脑首先在本地的<code>hosts</code>中寻找域名对应的ip，比如<code>localhost</code>是直接对应<code>127.0.0.0</code>。<br>如果能在hosts中寻找到，那么就直接进行下一步去加载网页了<br>但往往hosts中没有太多的对应，于是就下一步采用<code>DNS</code>寻找ip。</p>
<p>相对于hosts在本地，DNS在无其他配置情况下是通过网络查找的，而在这个时候，可能会有人在查找的结果中动一些手脚，明明是<code>11.11.11.11</code>的ip，却让它返回<code>22.22.22.22</code>。<br>那这样，这个网址就无法加载了。</p>
<p>此外，当Github访问速度过慢也可能是在DNS查找时比较慢，又或者因为这种大的网站一般有多个ip，我们访问了最远的ip，那么就会很慢了。</p>
<p>因此，通过修改hosts直接强制域名对应ip，使得DNS查找这个步骤可以省略，且访问速度较快的一个ip。</p>
<h1 id="一、获取需要解析的地址"><a href="#一、获取需要解析的地址" class="headerlink" title="一、获取需要解析的地址"></a>一、获取需要解析的地址</h1><p>为了确保加载，我解析的地址比较多，其中分为必须和可选（自己加上后发现效果比较好）</p>
<h2 id="必须"><a href="#必须" class="headerlink" title="必须"></a>必须</h2><ul>
<li>gist.github.com</li>
<li>github.com</li>
<li>assets-cdn.github.com</li>
<li>github.global.ssl.fastly.net</li>
</ul>
<h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><ul>
<li>www.github.com</li>
<li>api.github.com</li>
<li>github.githubassets.com</li>
<li>github.map.fastly.net</li>
<li>raw.githubusercontent.com</li>
<li>avatars0.githubusercontent.com</li>
<li>avatars1.githubusercontent.com</li>
<li>avatars2.githubusercontent.com</li>
<li>avatars3.githubusercontent.com</li>
</ul>
<h2 id="如何有针对性的选择添加解析的域名"><a href="#如何有针对性的选择添加解析的域名" class="headerlink" title="如何有针对性的选择添加解析的域名"></a>如何有针对性的选择添加解析的域名</h2><p>在加载github的时候打开开发者模式（F12），选择网络（Network），观察加载比较慢的或者直接加载失败的。</p>
<img src="/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/p1.png" class="" width="300" title="Network-Screenshot">
<p>如图，可以看到头像是加载失败的，找到网址是：avatars0.githubusercontent.com，把它加入需要解析的地址</p>
<h1 id="二、获取Github的DNS解析地址"><a href="#二、获取Github的DNS解析地址" class="headerlink" title="二、获取Github的DNS解析地址"></a>二、获取Github的DNS解析地址</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>采用<a href="https://www.ipaddress.com/ip-lookup" target="_blank" rel="noopener">IPAddress.com</a>查询ip地址。</p>
<p>输入需要查找的网址，如：assets-cdn.github.com，就可以看到结果。</p>
<img src="/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/ip1.png" class="" width="400" title="Find-ip">
<p>可以看到assets-cdn.github.com有四个对应ip</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>在用方法一的时候，发现电脑本来自动加载的ip和搜索出来的ip相差很大，因此可以直接采用电脑本来自己加载的时候采用的ip。</p>
<img src="/2020/02/24/Github%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E9%98%B2DNS%E6%B1%A1%E6%9F%93/ip2.png" class="" title="Auto-ip">
<p>又或者如果有自己的服务器可以尝试用服务器ping一下查看服务器所找到的ip。</p>
<p>又又或者直接试试网上别人提供的ip。</p>
<h1 id="三、修改Hosts文件"><a href="#三、修改Hosts文件" class="headerlink" title="三、修改Hosts文件"></a>三、修改Hosts文件</h1><p>打开系统的hosts文件，Windows是在<code>C:\Windows\System32\drivers\etc</code>，Mac和Linux是在<code>/etc</code><br>均需要采用管理员（root）打开</p>
<p>在文件最后加上需要的ip和域名对应的地址，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.255.112 gist.github.com</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<h1 id="四、刷新DNS缓存"><a href="#四、刷新DNS缓存" class="headerlink" title="四、刷新DNS缓存"></a>四、刷新DNS缓存</h1><p>对于Windwos用户，需要刷新一下DNS缓存</p>
<p>打开<code>cmd</code>或<code>powershell</code><br>输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></p>
<p>这样就可以使用我们自定义的hosts了</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>这其实是一个硬方法，由于ip可能会变且存在很多不同的ip，采用自定义ip其实并没有那么方便，一是不一定能找到最快的ip，二是一旦ip修改还得自行修改hosts文件，并没有那么方便。<br>但网上搜索了那么多，也没有找到一些好的方法，就先选择采用这个方法吧。</p>
<p>ps.几年前的采用修改hosts的方法是可以当半个梯子用的，不过现在好像并不太好用了。。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>DNS</tag>
        <tag>Hosts</tag>
      </tags>
  </entry>
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <url>/2020/02/23/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%85%A8%E6%96%87%EF%BC%89/</url>
    <content><![CDATA[<p>本文针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）</p>
<p>Next默认是会显示全文的，这样显然很不方便，因此需要一些方法去只显示前面一部分。</p>
<a id="more"></a>
<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>之后有两种方法</p>
<h2 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h2><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p>
<h2 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h2><p>在需要截断的地方加入：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到<code>修改配置</code>上面。</p>
<p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python触发win10通知栏通知提醒</title>
    <url>/2020/02/11/Python%E8%A7%A6%E5%8F%91win10%E9%80%9A%E7%9F%A5%E6%A0%8F%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[<p>在写代码的时候想在某些特定情况触发提示（后台自动运行的情况下），可以搜到的大部分是右下角提示之类比较丑的自定义提示，而其实现在win10已经有自己的通知栏，如果能用自带的通知栏绝对是一个很优秀的选择。搜了很久后发现了一个库叫做<strong>win10toast</strong>。</p>
<p>这个库最后是18年更新的，感觉是不会有更新了，但只要不会出问题就好，开发者github：<a href="https://github.com/jithurjacob/Windows-10-Toast-Notifications" target="_blank" rel="noopener">jithurjacob/Windows-10-Toast-Notifications</a></p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用pip安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install win10toast</span><br></pre></td></tr></table></figure>
<p>这个需要同时安装<strong>pywin32</strong>，没有安装的话pip会自动一起安装的。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> win10toast <span class="keyword">import</span> ToastNotifier</span><br><span class="line"></span><br><span class="line">toaster = ToastNotifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有icon的版本</span></span><br><span class="line">toaster.show_toast(<span class="string">"Hello World!!!"</span>,</span><br><span class="line">                   <span class="string">"Python is 10 seconds awsm!"</span>,</span><br><span class="line">                   icon_path=<span class="string">"custom.ico"</span>,</span><br><span class="line">                   duration=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无icon，采用python的icon，且采用自己的线程</span></span><br><span class="line">toaster.show_toast(<span class="string">"Example two"</span>,</span><br><span class="line">                   <span class="string">"This notification is in it's own thread!"</span>,</span><br><span class="line">                   icon_path=<span class="literal">None</span>,</span><br><span class="line">                   duration=<span class="number">5</span>,</span><br><span class="line">                   threaded=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待提示框关闭</span></span><br><span class="line"><span class="keyword">while</span> toaster.notification_active(): time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>提示框截图：<br><img src="/2020/02/11/Python%E8%A7%A6%E5%8F%91win10%E9%80%9A%E7%9F%A5%E6%A0%8F%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92/screenshot.png" class="" title="Screenshot"><br>本来想要一个可以永久长时间需要手动关闭的提示框，可惜似乎开发者并没有支持，经过尝试采用-1是有效的，但是会报错。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/104270913" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/104270913</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Python</tag>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装MPICH3.3.2</title>
    <url>/2019/11/23/Ubuntu%E5%AE%89%E8%A3%85MPICH3-3-2/</url>
    <content><![CDATA[<p>Linux上安装MPICH还算是方便的，虽然是indows系统，但搜索了一下windows安装的方法，最后选择放弃windows选择linux，不过虚拟机上的性能可能稍微差一点，但是作为并行的入门使用还是没有问题的。</p>
<p>主要步骤一开始是跟着网上搜索的，后来发现其实自带的readme写得很详细，推荐如果英文ok看readme就好。</p>
<a id="more"></a>
<p>此安装步骤成功安装于Ubuntu 16和Ubuntu 18。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>官网：<a href="https://www.mpich.org/" target="_blank" rel="noopener">https://www.mpich.org/</a><br>点击download以后选择<strong>mpich-3.3.2 (stable release)</strong>，下面自带的ubuntu平台的没太看懂于是就放弃了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载好以后解压并打开目录：（其实更喜欢右键解压哈哈哈）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzf mpich-3.3.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mpich-3.3.2</span><br></pre></td></tr></table></figure>
<p>如果看一下Readme的话可以发现必须要的是gcc，可选g++和Fortran。没有安装c的编译器的自行搜索</p>
<p>然后配置文件（这里没有用readme的重定向因为感觉看起来方便）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure -prefix=/usr/<span class="built_in">local</span>/mpich</span><br></pre></td></tr></table></figure>
<p>这里prefix是安装路径<br>如果有Fortran报错，又不需要支持Fortran的话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure -prefix=/usr/<span class="built_in">local</span>/mpich --<span class="built_in">disable</span>-fortran</span><br></pre></td></tr></table></figure>
<p>然后make file（此处等待5分钟）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>然后安装（此处继续等待五分钟）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果出错的话可以尝试make clean然后再来一遍</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>为了能全局使用，我们需要配置一下环境变量。这里被坑了很久，因为网上都是bash的配置，但我的默认shell是zsh，然后就一直配不出。。。</p>
<p>如果配置的是bash，打开bash的环境变量配置文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure><br>如果是zsh，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<h1 id="编辑环境变量"><a href="#编辑环境变量" class="headerlink" title="编辑环境变量"></a>编辑环境变量</h1><p>输入<strong>G</strong>移到最后一行，<br>按下<strong>i</strong>进行编辑<br>加入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/mpich/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后按下<strong>ESC</strong>，以及 <strong>:wq</strong>保存退出。</p>
<p>然后刷新一下环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>然后输入以下命令测试，应该会有反应</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> mpicc</span><br><span class="line"><span class="built_in">which</span> mpiexec</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/103212344" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/103212344</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MPICH</tag>
        <tag>parallelism</tag>
      </tags>
  </entry>
  <entry>
    <title>修改服务器端口</title>
    <url>/2019/10/01/%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>自己建一个服务器，最基础会遇到的问题就是被人随机攻击服务器，把默认端口修改掉就会减少很多啦</p>
<a id="more"></a>
<p>登录服务器以后，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p>
<p>然后会看到一行被注释的 #port 22</p>
<p>把”#”删掉然后把22换成其它端口号就好。</p>
<p>关于vim使用，要修改之前按一下i，修改结束按esc，然后输入”:wq”。</p>
<p>最后重新刷新一下配置（Debian 9）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><br>如不成功，可尝试以下命令：（Centos 7）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure></p>
<p>然后可以先试一下用默认端口登录，发现不可以登录</p>
<p>之后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@xxx.xxx.xx.xx -p abcd(端口号)</span><br></pre></td></tr></table></figure>
<p>会发现让输入密码，那就成功修改端口啦</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/101845927" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/101845927</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习-Calendar类</title>
    <url>/2019/09/25/JAVA%E5%AD%A6%E4%B9%A0-Calendar%E7%B1%BB/</url>
    <content><![CDATA[<p>Calendar类实个挺神奇的类，具体原因也没有细究，记一下它的用法。</p>
<p>Calendar类是一个基于Date类的类，它其中用到了Date，并且有相应的方法。而Calendar比Date增加了一些更通用的甚至，比如可以单独甚至年月日。</p>
<a id="more"></a>
<h1 id="新建一个（假）实例"><a href="#新建一个（假）实例" class="headerlink" title="新建一个（假）实例"></a>新建一个（假）实例</h1><p>和其他很多函数用法不一样，Calendar不用new来新建一个实例，而是用Calendar.getInstance()，因为某些原因所以我叫它（假）实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>这样我们就拥有了一个时间为现在时间的Calendar类c了。</p>
<h1 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h1><p>Calendar有两种设置方法。</p>
<h2 id="调用set"><a href="#调用set" class="headerlink" title="调用set"></a>调用set</h2><p>第一种调用set，用法是set(变量，值)<br>变量可以是Calendar.HOUR, Calendar.YEAR 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br></pre></td></tr></table></figure>
<p>这样年份就变成了2019</p>
<h2 id="调用setTime"><a href="#调用setTime" class="headerlink" title="调用setTime"></a>调用setTime</h2><p>setTime就是一个和Date有关的方法了，它的传参是一个Date类，为什么要用Date呢，因为Date的日期计算方式是距离一个年份的毫秒数，个人猜测比较方便。<br>用法就是setTime(date)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">c.setTime(d);</span><br></pre></td></tr></table></figure>
<h2 id="复制另一个Calendar时间"><a href="#复制另一个Calendar时间" class="headerlink" title="复制另一个Calendar时间"></a>复制另一个Calendar时间</h2><p>Calendar有一个方法是getTime()返回的是一个Date类，和setTime很像，因此我的解决方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">Calendar c2 = Calendar.getInstance();</span><br><span class="line">c1.setTime(c2.getTime());</span><br></pre></td></tr></table></figure>
<h1 id="Assert的使用"><a href="#Assert的使用" class="headerlink" title="Assert的使用"></a>Assert的使用</h1><p>这里就是为什么我认为我们构建的是一个（假）实例了。<br>阅读下述代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">Calendar c2 = Calendar.getInstance();</span><br><span class="line">assertEquals(c1, c2);</span><br></pre></td></tr></table></figure>
<p>它是不会报错的，十分神奇。。</p>
<p>再看另一端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">Calendar c2 = Calendar.getInstance();</span><br><span class="line">c1.set(Calendar.YEAR, <span class="number">1999</span>);</span><br><span class="line">assertEquals(c1, c2);</span><br></pre></td></tr></table></figure>
<p>当我们修改了年份以后，它是会报错的。</p>
<p>因此，我们得出的结论对于Calendar的assert，它只是对比了日期是否相同，并不对比指针是否一致</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/101376719" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/101376719</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7安装MariaDB数据库及基础配置</title>
    <url>/2019/07/18/CentOS-7%E5%AE%89%E8%A3%85MariaDB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为开发需求，在自己的CentOS 7服务器上远程链接数据库，搜索得知CentOS 7默认是MariaDB数据库而非MySQL。虽然安装MySQL也不是不可以，但是既然MariaDB和MySQL很像，那就直接上MariaDB吧。<br>安装教程是搜到的英文教程，主要是用来记录和帮助一些人翻译一下的。</p>
<a id="more"></a>
<h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><h2 id="一、增加MariaDB-Yum"><a href="#一、增加MariaDB-Yum" class="headerlink" title="一、增加MariaDB Yum"></a>一、增加MariaDB Yum</h2><p>首先需要新增一个文件，这边用vim写。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/MariaDB.repo</span><br></pre></td></tr></table></figure><br>在这个文件中加入这些内容，如果不会用vim的首先按<strong>i</strong>，然后粘贴上去，在按<strong>ESC</strong>，最后输入 <strong>:wq</strong>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mariadb]</span><br><span class="line">name &#x3D; MariaDB</span><br><span class="line">baseurl &#x3D; http:&#x2F;&#x2F;yum.mariadb.org&#x2F;10.1&#x2F;centos7-amd64</span><br><span class="line">gpgkey &#x3D; https:&#x2F;&#x2F;yum.mariadb.org&#x2F;RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck &#x3D; 1</span><br></pre></td></tr></table></figure></p>
<h2 id="二、安装MariaDB"><a href="#二、安装MariaDB" class="headerlink" title="二、安装MariaDB"></a>二、安装MariaDB</h2><p>最好在root用户下安装（非root用户我后面几个命令报错了）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mariadb mariadb-server</span><br></pre></td></tr></table></figure></p>
<h2 id="三、配置MariaDB"><a href="#三、配置MariaDB" class="headerlink" title="三、配置MariaDB"></a>三、配置MariaDB</h2><p>启动mariadb<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mariadb</span><br></pre></td></tr></table></figure></p>
<p>设置开机自启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br></pre></td></tr></table></figure></p>
<p>设置root密码等相关，这其中包括密码等一些基本设置，一开始是没有密码的，所以按回车就可以了。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure></p>
<h2 id="四、登录"><a href="#四、登录" class="headerlink" title="四、登录"></a>四、登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<h2 id="五、查看版本"><a href="#五、查看版本" class="headerlink" title="五、查看版本"></a>五、查看版本</h2><p>MariaDB还真是MySQL的亲家，查看版本命令竟然使用mysql的。。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -V</span><br></pre></td></tr></table></figure></p>
<h2 id="六、新增用户"><a href="#六、新增用户" class="headerlink" title="六、新增用户"></a>六、新增用户</h2><p>登录到root用户到数据库下<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.user(Host,<span class="keyword">User</span>,<span class="keyword">Password</span>) <span class="keyword">values</span>(<span class="string">"localhost"</span>,<span class="string">"admin"</span>,<span class="keyword">password</span>(<span class="string">"admin"</span>));</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="七、开启远程访问"><a href="#七、开启远程访问" class="headerlink" title="七、开启远程访问"></a>七、开启远程访问</h2><p>首先登录到root用户下数据库，然后输入以下句子：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><br>其中‘root’可以替换成任何已创建的用户，‘123456’处是密码。<br>这样就可以远程访问了。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/96387164" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/96387164</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MariaDB</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 基础语句</title>
    <url>/2019/05/11/SQL-%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<ul>
<li>SQL不区分大小写</li>
<li>SQL需要分号<a id="more"></a>
</li>
</ul>
<h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><h2 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用法一</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">table</span>] <span class="keyword">AS</span> [<span class="keyword">select</span> <span class="keyword">statement</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#样例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">38</span> <span class="keyword">AS</span> altitude, <span class="number">122</span> <span class="keyword">AS</span> longitude, “Berkeley” <span class="keyword">AS</span> <span class="keyword">name</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">42</span>,             <span class="number">71</span>,               <span class="string">"Cambridge"</span>        <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">45</span>,             <span class="number">93</span>,               <span class="string">"Minneapolis"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">table</span>] [(create_definition,...)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#用法样例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> numbers (n, note);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> numbers (n <span class="keyword">UNIQUE</span>, note);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> numbers (n, note <span class="keyword">DEFAULT</span> <span class="string">"No comment"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>UNIQUE</strong>: 使得n是唯一的<br><strong>DEFAULT</strong>: 设置默认值</p>
<h1 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [<span class="keyword">table</span>];        <span class="comment">#删除表</span></span><br></pre></td></tr></table></figure>
<h1 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">table</span>] <span class="keyword">VALUES</span> [(<span class="keyword">value</span>)];         <span class="comment">#对一个表进行一整行的插入</span></span><br><span class="line"><span class="comment">#example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> numbers <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">"a"</span>), (<span class="number">5</span>, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">table</span>(<span class="keyword">key</span>)] <span class="keyword">VALUES</span> [(<span class="keyword">value</span>)];    <span class="comment">#对一个表的某几列进行插入，剩下默认为null</span></span><br><span class="line"><span class="comment">#example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> numbers(n) <span class="keyword">VALUES</span> (<span class="number">0</span>), (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [<span class="keyword">table</span>] [<span class="keyword">select</span> <span class="keyword">statement</span>];       <span class="comment">#用select来插入</span></span><br><span class="line"><span class="comment">#example</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> numbers(n) <span class="keyword">SELECT</span> n+<span class="number">8</span> <span class="keyword">from</span> numbers;</span><br></pre></td></tr></table></figure>
<h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [<span class="keyword">table</span>] <span class="keyword">SET</span> [<span class="keyword">statement</span>] <span class="keyword">WHERE</span> [<span class="keyword">statement</span>];   <span class="comment">#通过where筛选需要更新的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">UPDATE</span> numbers <span class="keyword">SET</span> note = <span class="string">"aaa"</span> <span class="keyword">WHERE</span> n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [<span class="keyword">table</span>] <span class="keyword">WHERE</span> [<span class="keyword">statement</span>];           <span class="comment">#通过where筛选需要删除的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> numbers <span class="keyword">WHERE</span> note = <span class="string">"No comment"</span>;</span><br></pre></td></tr></table></figure>
<h1 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [expression] <span class="keyword">AS</span> [<span class="keyword">name</span>], [expression] <span class="keyword">AS</span> [<span class="keyword">name</span>], …;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">columns</span>] <span class="keyword">FROM</span> [<span class="keyword">table</span>] <span class="keyword">WHERE</span> [condition] <span class="keyword">ORDER</span> <span class="keyword">BY</span> [<span class="keyword">order</span>] <span class="keyword">LIMIT</span> [<span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># exapmle 1</span></span><br><span class="line"><span class="keyword">SELECT</span> a.parent, b.child</span><br><span class="line"><span class="keyword">FROM</span> parents <span class="keyword">AS</span> a, parents <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.child = b.parent;</span><br><span class="line"></span><br><span class="line"><span class="comment"># example 2</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grandparents <span class="keyword">AS</span></span><br><span class="line"> <span class="keyword">SELECT</span> a.parent <span class="keyword">AS</span> grandog, b.child <span class="keyword">AS</span> granpup</span><br><span class="line">   <span class="keyword">FROM</span> parents <span class="keyword">AS</span> a, parents <span class="keyword">AS</span> b</span><br><span class="line">   <span class="keyword">WHERE</span> b.parent = a.child;</span><br></pre></td></tr></table></figure>
<h1 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC      <span class="comment">#降序</span></span><br><span class="line">ASC       <span class="comment">#升序（默认）</span></span><br><span class="line"></span><br><span class="line">order by A,B             <span class="comment">#这个时候都是默认按升序排列</span></span><br><span class="line">order by A desc,B        <span class="comment">#这个时候 A 降序，B 升序排列</span></span><br><span class="line">order by A ,B desc       <span class="comment">#这个时候 A 升序，B 降序排列</span></span><br></pre></td></tr></table></figure>
<h1 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">max()</span><br><span class="line">min()</span><br><span class="line">avg()</span><br><span class="line">sum()</span><br><span class="line">count()</span><br></pre></td></tr></table></figure>
<h1 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">columns</span>] <span class="keyword">from</span> [<span class="keyword">table</span>] <span class="keyword">group</span> <span class="keyword">by</span> [expression] <span class="keyword">having</span> [expression];</span><br></pre></td></tr></table></figure>
<h1 id="Numerical-Expressions"><a href="#Numerical-Expressions" class="headerlink" title="Numerical Expressions"></a>Numerical Expressions</h1><p>Combine values:   +, -, *, /, %, and, or<br>Transform values: abs, round, not, -<br>Compare values:   &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, !=, =</p>
<h1 id="String-Expressions"><a href="#String-Expressions" class="headerlink" title="String Expressions"></a>String Expressions</h1><p>Combine: ||        字符串拼接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT <span class="string">"hello,"</span> || <span class="string">" world"</span>;</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>
<p>substr(string, start_index, length)    获取字串，start_index从1开始<br>instr(string, substring)                      查找substring在string中的index</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE TABLE phrase AS SELECT <span class="string">"hello, world"</span> AS s;</span><br><span class="line">sqlite&gt; SELECT substr(s, 4, 2) || substr(s, instr(s, <span class="string">" "</span>)+1, 1) FROM phrase;</span><br><span class="line">low</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/90105733" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/90105733</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode——415. Add Strings(大数加法)</title>
    <url>/2019/03/02/Leetcode%E2%80%94%E2%80%94415-Add-Strings-%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>
</blockquote>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题很明显就是一个字符串的大数相加。</p>
<p>首先相同位数的相加，然后考虑一下进位符。<br>如果一个数没有第k位，那么和的第k位就是另一个数的第k位和进位符相加。<br>最后需要注意以下最后会不会有多出一个进位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = k;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t += num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t += num1[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t += num2[j] + num1[i] - <span class="string">'0'</span> - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = t / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="string">'0'</span> + t % <span class="number">10</span>;</span><br><span class="line">            s = c + s;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="string">"1"</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/88075414" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/88075414</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>新版OpenGL学习入门（三）——对着色器的一些理解</title>
    <url>/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>在写完OpenGL项目后，再次回顾并总结一下用到的一些知识。</p>
<p><em>注意此博文可能需要先入门，否则可能有些难懂</em></p>
<p>我做了一个简易的皮卡丘版的跳一跳，有兴趣的可以看一下我的Github：<a href="https://github.com/yueyue200830/Jumping-Pikachu" target="_blank" rel="noopener">Jumping Pikachu</a></p>
<img src="/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/Pikachu.png" class="" title="Pikachu">
<p>整个项目的一个亮点是在跳跃失败了以后会产生爆破的效果，这个效果需要用到<strong>几何着色器</strong>。</p>
<h1 id="关于着色器"><a href="#关于着色器" class="headerlink" title="关于着色器"></a>关于着色器</h1><p>我整个项目的学习链接：<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL</a></p>
<blockquote>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，3D坐标转为2D坐标的处理过程叫做<strong>图形渲染管线</strong></p>
</blockquote>
<p>而在图形渲染管线也分为好几个步骤，以下为图示</p>
<img src="/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/pipeline.png" class="" title="图形渲染管线的过程">
<p>其中三个着色器就是把数据处理成另一类数据然后交给下一个着色器继续处理，最后出来就是我们要的内容了。</p>
<ul>
<li><strong>顶点着色器(vs)</strong> 是最初用来处理顶点坐标的，一般会对坐标做一些计算</li>
<li><strong>几何着色器(gs)</strong> 是对原坐标进行一些修改，个人感觉适用于一些特效</li>
<li><strong>片段着色器(fs)</strong> 是对图形进行涂色，并最终输出。</li>
</ul>
<p>注意：这三个顺序是固定的，其中几何着色器并不是一定要用的。</p>
<h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>一般一个点储存了它的三维坐标、三维法向量和二维的纹理坐标。<br>其中法向量是为了计算光线的，而纹理坐标则是为了纹理贴图。</p>
<p>以下的代码是我项目中的，其中out是传到后面一个着色器的东西，而gl_Position是该点的输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">version <span class="number">330</span> core</span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 aTexCoords;</span><br><span class="line"></span><br><span class="line">out VS_OUT &#123;</span><br><span class="line">	vec3 FragPos;</span><br><span class="line">	vec3 Normal;</span><br><span class="line">    vec2 texCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vs_out.FragPos = vec3(model * vec4(aPos, <span class="number">1.0</span>));</span><br><span class="line">	vs_out.Normal = mat3(transpose(inverse(model))) * aNormal;</span><br><span class="line">    vs_out.texCoords = aTexCoords;</span><br><span class="line"></span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>集合着色器可以对坐标进行一些修改，而我的项目中皮卡丘爆破的场景就是通过这个进行修改的。</p>
<p>爆破的效果是通过对每一个碎片向它的法向量移动一段距离而获得的，一下是教程中的爆破效果。</p>
<img src="/2019/03/02/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/geometry_shader_explosion.png" class="" title="爆破">
<p>以下是我项目的代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (triangles) in;</span><br><span class="line">layout (triangle_strip, max_vertices = <span class="number">3</span>) out;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">	vec3 FragPos;</span><br><span class="line">	vec3 Normal;</span><br><span class="line">    vec2 texCoords;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 Normal;</span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function">vec4 <span class="title">explode</span><span class="params">(vec4 position, vec3 normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> magnitude = <span class="number">2.0</span>;</span><br><span class="line">	vec3 direction;</span><br><span class="line">	vec4 temp;</span><br><span class="line">	<span class="keyword">if</span> (time &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">		direction = normal * (-<span class="built_in">log</span>(<span class="number">1.0</span>- time)) * magnitude;</span><br><span class="line">		temp = position + vec4(direction, <span class="number">0.0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		temp = position;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">GetNormal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 a = vec3(gl_in[<span class="number">0</span>].gl_Position) - vec3(gl_in[<span class="number">1</span>].gl_Position);</span><br><span class="line">    vec3 b = vec3(gl_in[<span class="number">2</span>].gl_Position) - vec3(gl_in[<span class="number">1</span>].gl_Position);</span><br><span class="line">    <span class="keyword">return</span> normalize(cross(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec3 normal = GetNormal();</span><br><span class="line"></span><br><span class="line">    gl_Position = explode(gl_in[<span class="number">0</span>].gl_Position, normal);</span><br><span class="line">	Normal = gs_in[<span class="number">0</span>].Normal;</span><br><span class="line">	FragPos = gs_in[<span class="number">0</span>].FragPos;</span><br><span class="line">    TexCoords = gs_in[<span class="number">0</span>].texCoords;</span><br><span class="line">    EmitVertex();</span><br><span class="line">    gl_Position = explode(gl_in[<span class="number">1</span>].gl_Position, normal);</span><br><span class="line">	Normal = gs_in[<span class="number">1</span>].Normal;</span><br><span class="line">	FragPos = gs_in[<span class="number">1</span>].FragPos;</span><br><span class="line">    TexCoords = gs_in[<span class="number">1</span>].texCoords;</span><br><span class="line">    EmitVertex();</span><br><span class="line">    gl_Position = explode(gl_in[<span class="number">2</span>].gl_Position, normal);</span><br><span class="line">	Normal = gs_in[<span class="number">2</span>].Normal;</span><br><span class="line">	FragPos = gs_in[<span class="number">2</span>].FragPos;</span><br><span class="line">    TexCoords = gs_in[<span class="number">2</span>].texCoords;</span><br><span class="line">    EmitVertex();</span><br><span class="line">    EndPrimitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>片段着色器就是最后进行上色的部分，由于颜色的亮度和光照有关，因此其中包含计算光照和颜色。<br>对于不同反射等计算是比较困难的，我就借鉴了教程上的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Material</span> &#123;</span></span><br><span class="line">    sampler2D diffuse;</span><br><span class="line">    sampler2D specular;</span><br><span class="line">    <span class="keyword">float</span> shininess;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirLight</span> &#123;</span></span><br><span class="line">    vec3 direction;</span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 Normal;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform DirLight dirLight;</span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">CalcDirLight</span><span class="params">(DirLight light, vec3 normal, vec3 viewDir)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec3 norm = normalize(Normal);</span><br><span class="line">    vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">	vec3 result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line"></span><br><span class="line">	FragColor = vec4(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">CalcDirLight</span><span class="params">(DirLight light, vec3 normal, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 lightDir = normalize(-light.direction);</span><br><span class="line">    <span class="comment">// diffuse shading</span></span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// specular shading</span></span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, normal);</span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// combine results</span></span><br><span class="line">    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来说，着色器虽然较难入手，但是着色器可以很有效的帮助我们进行变换等其他操作，尤其是十分优秀的几何着色器。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/88071644" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/88071644</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL——next_permutation&amp;prev_permutation</title>
    <url>/2019/02/07/STL%E2%80%94%E2%80%94next-permutation-prev-permutation/</url>
    <content><![CDATA[<p>next_permutation和prev_permutation是对c++求全排列的函数，分别可以求出下一个全排列和前一个全排列。</p>
<a id="more"></a>
<p>这里以next_permutation为例，来看一下c++官网的定义：</p>
<blockquote>
<p>default: bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);<br>custom: bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);</p>
</blockquote>
<p>可以看到和sort的用法很像，只需要输入first和last就可以返回是否有下一个，如果有的话会直接在内部排序出现下一个。</p>
<p>同时可以选项是comp函数，可以自定义排序方式，默认为字典序。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>题目：<a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">leetcode 46. Permutations</a></p>
<p>这是一道全排列的题目，普通解法有dfs和非递归的查找，看解答时发现了这个函数，减少了不少代码量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        ans.push_back(nums);</span><br><span class="line">        <span class="keyword">while</span> (next_permutation(nums.begin(), nums.end())) &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/86771956" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/86771956</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode——42. Trapping Rain Water</title>
    <url>/2019/02/03/Leetcode%E2%80%94%E2%80%9442-Trapping-Rain-Water/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
</blockquote>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>输入：[0,1,0,2,1,0,1,3,2,1,2,1]<br>答案：6（蓝色部分）</p>
<img src="/2019/02/03/Leetcode%E2%80%94%E2%80%9442-Trapping-Rain-Water/rainwatertrap.png" class="" title="example">
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>本题就是需要寻找凹下去比旁边低的部分。</p>
<p>对于题意的分析部分比较难，如果能正确分析出题意基本就可以解决了。</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>这个解法是官方的解法，主要写一下思路：</p>
<p>对于每一条块，把它左边和右边的块一份为二，分别寻找出它左边和右边最高块的高度，显然它最后加了水的高度就是它左右两遍高度的最大值中小的那个。</p>
<img src="/2019/02/03/Leetcode%E2%80%94%E2%80%9442-Trapping-Rain-Water/solution.png" class="" title="solution">
<p>如图红色为随机的一条，两条黑色的是其左右两边最高的两根，显然最后注满的水量至少之蓝色这么多，也就是左右两根黑色中比较矮的那根的长度。</p>
<p>因此<strong>sum  = sum(min(left_max[i], right_max[i]))</strong></p>
<p>比较普通又方便的一种解法是用dp记录left_max和right_max，时间复杂度和空间复杂度都为O(n)。</p>
<p>而另一种可以更快的方法是用left和right两个来左右一起遍历，同时记录遍历过的left_max和right_max。<br>只要比较现在遍历过的里面左右的最大值，最大值比较小的那侧现在指向的那块最后的注水量就是那侧遍历到的最大的值。（因为另一侧的最大值一定比这一侧的最大值大）<br>即，假设现在left_max比right_max小，那么第left个左边所有的值都知道了，最大值为left_max，而它右边的最大值一定会大于等于right_max。因此min(right_max[i], left_max[i]) = left_max[i]。<br>这样遍历的时间复杂度是O(n)（只需要遍历n次，比dp的2n次少一半），空间复杂度为O(1)（只需要另外4个数记录就好，而dp的额外空间是2n）</p>
<p>附上官方代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">      height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);</span><br><span class="line">      ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);</span><br><span class="line">      --right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>这个是我绞尽脑汁后的一个比较复杂的解法，时间复杂度O(n)，空间复杂度最大O(n)（用stack）</p>
<p>做法是从左往右遍历，遇到可以注水的地方就先把暂时可以注的水给注入。</p>
<p>如样例中有一部分[2,1,0,1,3]<br>当遇到右侧1的时候，也就是[2,1,0,1]时，在0中注入1的水量，这样就变成了[2,1,1,1]了<br>当遇到3时，对所有的1都注入1的水量，变成[2,2,2,2,3]。</p>
<p>整个的难点在于用stack的记录，对于同一个高度块只记录一次，每次需要同时记录高度和位置，因此需要用结构体来记录。<br>又由于是从左往右遍历的，每次记录同高度下最右边的那条。</p>
<p>因为每次遍历完已经填平了所有遍历过的水坑，因此stack中记录的一定是不可以再注入水的，也就是递增或者递减的一堆数。</p>
<p>当每次遇到可以注水的时候，注水量为(mini(left_height, right_height) - current_height)*(left_position-right_position-1)（如有不理解可以考虑一下刚才的example）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="keyword">int</span> p;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;num&gt; q;</span><br><span class="line">        num tmp, last;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        tmp.n = height[<span class="number">0</span>];</span><br><span class="line">        tmp.p = <span class="number">0</span>;</span><br><span class="line">        q.push(tmp);</span><br><span class="line">        tmp.n = height[<span class="number">1</span>];</span><br><span class="line">        tmp.p = <span class="number">1</span>;</span><br><span class="line">        q.push(tmp);</span><br><span class="line">        <span class="keyword">int</span> n = max(height[<span class="number">0</span>], height[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">            tmp = q.top();</span><br><span class="line">            <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span> &amp;&amp; n &gt; tmp.n &amp;&amp; tmp.n &lt;= height[i]) &#123;</span><br><span class="line">                last = tmp;</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp = q.top();</span><br><span class="line">                s += (min(tmp.n, height[i]) - last.n) * (i - tmp.p - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.n = height[i];</span><br><span class="line">            tmp.p = i;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp.n &gt; n) &#123;</span><br><span class="line">                n = tmp.n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/86755967" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/86755967</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用wget的方法</title>
    <url>/2019/01/02/windows%E4%B8%8B%E4%BD%BF%E7%94%A8wget%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>GNU Wget（常简称为Wget）是一个在网络上进行下载的简单而强大的自由软件，其本身也是GNU计划的一部分。<br>它的名字是“World Wide Web”和“Get”的结合，同时也隐含了软件的主要功能。<br>当前它支持通过HTTP、HTTPS，以及FTP这三个最常见的TCP/IP协议协议下载。</p>
</blockquote>
<p>wget在linux下很方便就可以安装使用了，但似乎官网并没有给windows下一个安装包之类的东西，搜了好久后来发现了两个解决方法。</p>
<a id="more"></a>
<h1 id="用choco安装"><a href="#用choco安装" class="headerlink" title="用choco安装"></a>用choco安装</h1><p>这是我在自己电脑上方法，不过似乎下面一个方法更加方便删除</p>
<h2 id="安装chocolatey"><a href="#安装chocolatey" class="headerlink" title="安装chocolatey"></a>安装chocolatey</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="string">"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe"</span> -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command <span class="string">"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))"</span> &amp;&amp; SET <span class="string">"PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"</span></span><br></pre></td></tr></table></figure>
<h2 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">choco install wget</span><br></pre></td></tr></table></figure>
<p>这样就可以直接使用了</p>
<h1 id="用已编译的包"><a href="#用已编译的包" class="headerlink" title="用已编译的包"></a>用已编译的包</h1><p>有些地方会放出来一些windows下的包，只要在cmd中打开到相应文件夹就可以使用了，或者应该也可以配置环境变量</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85638286" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85638286</a></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（三）——逆元</title>
    <url>/2018/12/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>当运算时需要求模的时候，可以直接做的有+-*但是不满足/</p>
<p>而逆元就是通过某种运算来达到求(a/b)%p的结果</p>
<a id="more"></a>
<blockquote>
<p>当 $b*c ≡ 1$ (mod p)时，</p>
<p>有 (a / b) % p = (a / b * b * c) % p = (a * c) % p</p>
<p>这里c就是b关于p的逆元 </p>
</blockquote>
<p>那么如何求c呢</p>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<p>当p为素数时，有 $a^p$ ≡ a(mod p)</p>
</blockquote>
<p>故有$a^p$ ≡ 1(mod p)</p>
<p>因此a关于p的逆元就是$a^{p-2}$</p>
<p>这个幂可以使用<strong>快速幂</strong>来得出</p>
<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><blockquote>
<p>对于不完全为0的非负整数a,b，必存在整数x,y，满足ax+by=gcd(a,b)</p>
</blockquote>
<p>因此，求a*x≡1(mod p)</p>
<p>即求ax+py=1=gcd(a,b)/gcd(a,b)</p>
<p>也就是先求出ax+py=gcd(a,b)</p>
<p>然后x=x/gcd(a,b)即可</p>
<p>注意：x可能为负的，需要x=x+p</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span>    <span class="comment">//这是扩展欧几里得</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = exgcd(b, a%b, x, y);</span><br><span class="line">    ll tmp = y;</span><br><span class="line">    y = x - a / b * y;</span><br><span class="line">    x = tmp;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k = exgcd(k ,p ,x ,i);</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += p;                     <span class="comment">//防止x为负</span></span><br><span class="line">x = x / k;</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85334843" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85334843</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（二）——快速幂</title>
    <url>/2018/12/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>快速幂是用来解决$n^k \mod N$，将其时间复杂度从 $O(n)$ 减少到 $O(\log n)$ 。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先，了解一个模运算的概念</p>
<blockquote>
<p>(a+b) mod N = (a mod N + b mod N) mod N</p>
<p>(a * b) mod N = (a mod N * b mod N) mod N</p>
</blockquote>
<p>然后，对于一个数k，把它转换为二进制，</p>
<p>如11 = 1011</p>
<p>那么 $ n^{11} = n^8 <em> n^2 </em> n^1 $ 。</p>
<p>于是 $n^{11} \mod N = (n^8 \mod N) <em> (n^2 \mod N) </em> (n^1 \mod N)$</p>
<p>那么在循环过程中只需要一直记录$n^{2^m}$，每次判断$2^m$对应$k$的二进制位是$0$（不要）是$1$（要）就可以</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll n, ll k, ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll num = <span class="number">1</span>, t = n;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            num = num * t % N;</span><br><span class="line">        t = t * t % N;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于快速幂的扩展还有一个矩阵快速幂，它是对于矩阵做一个快速幂的处理，可以用于求斐波那契数列第n项模N </p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85333813" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85333813</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习（一）——欧几里德算法&amp;扩展欧几里得算法</title>
    <url>/2018/12/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最大公约数-欧几里德算法（gcd）"><a href="#最大公约数-欧几里德算法（gcd）" class="headerlink" title="最大公约数/欧几里德算法（gcd）"></a>最大公约数/欧几里德算法（gcd）</h1><p>欧几里德算法又称辗转相除法，是用于求最大公约数的方法，证明可以度娘。</p>
<p>个人简单脑补就是a和b两个数的模还是a和b的最大公约数</p>
<p>int类型 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span> ? b : gcd(b, a%b);&#125;</span><br></pre></td></tr></table></figure>
<p>long long类型的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span> ? b : gcd(b, a%b);&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h1><p>概念： </p>
<blockquote>
<p>对于不完全为0的非负整数a,b</p>
<p>必存在整数x,y，满足ax+by = gcd(a, b)</p>
</blockquote>
<p>运用：</p>
<blockquote>
<p>求解ax+by=c，用扩展欧几里得求得后*c/gcd(a,b)</p>
</blockquote>
<p>求a*x≡1(mod p)</p>
<p>即求ax+py=1=gcd(a,b)/gcd(a,b)</p>
<p>也就是先求出ax+py=gcd(a,b)</p>
<p>然后x=x/gcd(a,b)即可</p>
<p>注意：x可能为负的，需要x=x+p</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = exgcd(b, a%b, x, y);</span><br><span class="line">    ll tmp = y;</span><br><span class="line">    y = x - a / b * y;</span><br><span class="line">    x = tmp;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85333585" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85333585</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Nowcoder Girl第二届挑战赛——题解</title>
    <url>/2018/12/24/2018-Nowcoder-Girl%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%8C%91%E6%88%98%E8%B5%9B%E2%80%94%E2%80%94%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>记录一下自己打得如此渣渣还是进了前120，希望面试能顺利，要求不高，第60名就好，我想要奖品，顺便求奖状啊我要奖学金加分（有钱）</p>
<p>Update: 第一次还是挺顺利的，奖品加分都有啦hhh</p>
<p>2020update：都一年过去了，2019也比完了，题目还是没有上来？？？</p>
<a id="more"></a>
<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>这是一道坑题，题意理解错了，是歌曲已经下载的秒数不是从下载到开始过了多少秒。。。</p>
<p>其实就算是一道追及问题吧，求一下下一次重头播放的时候是第几秒</p>
<p>代码等有题目了再更（大概不会有了）</p>
<h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>唔。。这也是坑题一道啊，我看了半天，快1.5小时的时候才改过来，超级浪费时间。。。</p>
<h2 id="求D-x"><a href="#求D-x" class="headerlink" title="求D(x)"></a>求D(x)</h2><p>这就是一道数学题，求$\left(\frac{x}{y}\right)^y$的最大值，其实就是求导。</p>
<p>至于$ \left( \big( \frac{x}{y} \big)^y \right) &gt; 0$怎么求，这就是高数的知识了，对原式先取对数，也就是对$y \ln{\frac{x}{y}}$求导</p>
<p>推导过程就不写了，不会的话翻高数书吧（可能某些地区的高考知识。。）</p>
<p>最后求得$x \leq e * y$</p>
<p>所以在代码里直接$y=x/e$就好</p>
<h2 id="判断是有限小数还是无限小数"><a href="#判断是有限小数还是无限小数" class="headerlink" title="判断是有限小数还是无限小数"></a>判断是有限小数还是无限小数</h2><p>其实对于有限小数，就是要整除$10^n$，因此当且仅当分母只是2和5的倍数时才行。</p>
<p>不过有一个小坑在于记得分子分母需要先约分一下，用gcd求一下就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:gcd(b,a%b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是有限小数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n%<span class="number">2</span> == <span class="number">0</span>) n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n%<span class="number">5</span> == <span class="number">0</span>) n /= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n, i;</span><br><span class="line">    <span class="keyword">double</span> e = <span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &lt;=  n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">int</span>(i/e+<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">int</span> x = gcd(<span class="keyword">int</span>(i),k);</span><br><span class="line">        k /= x;</span><br><span class="line">        <span class="keyword">bool</span> ok = yes(k);</span><br><span class="line">        <span class="keyword">if</span>(ok) s -= <span class="keyword">int</span>(i);</span><br><span class="line">        <span class="keyword">else</span> s += <span class="keyword">int</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>第三题题意又有点坑。。需要所有连续x个都满足才行。。。</p>
<p>感觉读懂题其实就没什么难点了</p>
<p>求出最坏情况就好</p>
<p>这个代码好像本地保存有一点问题，可能最后是在网上直接修改的，我稍微修改了一下，不能保证一定是对的，等题目出来了再检查一下，但思路是没问题的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, x, c, m, i, j, s, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; c &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;j);</span><br><span class="line">        a[j<span class="number">-1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        j += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = x<span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        j += a[i];</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; c) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[k]==<span class="number">1</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[k]++;</span><br><span class="line">            j++;</span><br><span class="line">            s++;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        j -= a[i-x+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他未完待续。。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/85236298" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/85236298</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习——Servlet+表单提交</title>
    <url>/2018/12/21/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Servlet-%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>网上写servlet的大神不少，记录一下遇到的问题。</p>
<p>配置是ecplise+tomcat9.0</p>
<p>关于servlet的创建方法：项目右键-&gt;new-&gt;servlet，然后package和class的名字随便命名，之后全部默认或者点finish就好。</p>
<img src="/2018/12/21/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Servlet-%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4/p1.png" class="" title="创建servlet">
<ul>
<li>servlet配置现在有两种，网上比较多的是用xml来的，但是新版的可以通过 @配置注解，新生成的servlet是自带的，不需要任何配置</li>
<li>一开始找到了一个直接用service的，但似乎它直接扩展了底层的内容，可以用doget和dopost来解决</li>
<li>中文字符乱码问题，需要设置response.setCharacterEncoding(“UTF-8”)和request.setCharacterEncoding(“UTF-8”)。需要放在最前面，否则可能在传入值了以后就没用了。</li>
</ul>
<p>这里写的是一个实现登录功能的表单提交的servlet，项目名字叫做Servlet_try4，表单一共就user和password两个内容，最后跳转到hellp.jsp显示登录状态</p>
<p>关于表单部分，在form里加上这个就好<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"servlet"</span>  <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>至于表单内部的内容，记得写上name，servlet是根据name来获取的。</p>
<p><strong>原来代码：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class Servlet_try4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/Servlet_try4"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet_try4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Servlet_try4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 设置字符编码</span></span><br><span class="line">		request.setCharacterEncoding(<span class="string">"utf8"</span>);</span><br><span class="line">		<span class="comment">// 从request对象中获取username,password</span></span><br><span class="line">		String username = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">		String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给将要request的对象写入信息</span></span><br><span class="line">		request.setAttribute(<span class="string">"user"</span>, username);</span><br><span class="line">		request.setAttribute(<span class="string">"password"</span>, password);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将页面转发到欢迎页面</span></span><br><span class="line">		RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">"/hello.jsp"</span>);</span><br><span class="line">		dispatcher.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		response.getWriter().append(<span class="string">"Served at: "</span>).append(request.getContextPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>改进代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class Servlet_try4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/Servlet_try4"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet_try4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Servlet_try4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		response.getWriter().append(<span class="string">"Served at: "</span>).append(request.getContextPath());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置字符编码</span></span><br><span class="line">		request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从request对象中获取username,password</span></span><br><span class="line">		String username = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">		String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给将要request的对象写入信息</span></span><br><span class="line">		request.setAttribute(<span class="string">"user"</span>, username);</span><br><span class="line">		request.setAttribute(<span class="string">"password"</span>, password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="comment">	 *      response)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">		response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		doGet(request, response);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将页面转发到欢迎页面</span></span><br><span class="line">		RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">"/hello.jsp"</span>);</span><br><span class="line">		dispatcher.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唔。。虽然这个可以成功，但是在后续学习上发现对于表单提交，最好把doGet的内容全部写到doPost里，这里就不更新了，但是希望可以注意一下~</p>
<p>附：<a href="https://blog.csdn.net/qq_26676207/article/details/53483135" target="_blank" rel="noopener">doGet()和doPost()的区别</a></p>
<p>ps.这里只能实现通过submit做一个表单提交，但是对于很多网页来说需要或许数据库也要调用servlet，又或者想要在提交前做一些什么判断，这样子的话可以尝试一下ajax来跳转到servlet。</p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/84984287" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84984287</a></p>
]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习——MySQL</title>
    <url>/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/</url>
    <content><![CDATA[<p>记录一下初学MySQL，版本：MySQL8.0。</p>
<p>首先直接msi安装MySQL，虽然占内存，但是省力，全部默认即可</p>
<h1 id="新建MySQL"><a href="#新建MySQL" class="headerlink" title="新建MySQL"></a>新建MySQL</h1><p>直接点击默认的那个，然后创建一个schema，改好名字点apply就可以</p>
<img src="/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/p1.png" class="" title="新建schema">
<p>然后在项目的table那边新建table</p>
<img src="/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/p2.png" class="" title="新建table">
<p>这次需要创建列表信息，这样子它可以帮你默认创建一个，很方便，创建好了点apply就好</p>
<img src="/2018/12/13/JavaWeb%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94MySQL/p3.png" class="" title="新建列表信息">
<h1 id="连接MySQL到Ecplise"><a href="#连接MySQL到Ecplise" class="headerlink" title="连接MySQL到Ecplise"></a>连接MySQL到Ecplise</h1><p>参考：<a href="https://blog.csdn.net/fanjianwucmx/article/details/54882044" target="_blank" rel="noopener">eclipse连接mysql数据库</a></p>
<p>代码改的是别人的，url是有做过修改，因为第一次没有连接默认的数据库。。</p>
<p>有几个多重定向的报错，选择sql的就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> js_try8_mail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailTry</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 加载数据库驱动 com.mysql.jdbc.Driver</span></span><br><span class="line">		String driver = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">		<span class="comment">// 获取mysql连接地址</span></span><br><span class="line">		String url = <span class="string">"jdbc:mysql://127.0.0.1:3306/163mail?&amp;useSSL=false&amp;serverTimezone=UTC"</span>;</span><br><span class="line">		<span class="comment">// 数据名称</span></span><br><span class="line">		String username = <span class="string">"root"</span>;</span><br><span class="line">		<span class="comment">// 数据库密码</span></span><br><span class="line">		String password = <span class="string">"xxxxxxxx"</span>;</span><br><span class="line">		<span class="comment">// 获取一个数据的连接</span></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 获取连接的一个状态</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(driver);</span><br><span class="line">			<span class="comment">// getConnection()方法，连接MySQL数据库！</span></span><br><span class="line">			conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">			<span class="keyword">if</span> (!conn.isClosed())</span><br><span class="line">				System.out.println(<span class="string">"数据库连接成功！"</span>);</span><br><span class="line">			<span class="comment">// 创建statement类对象，用来执行SQL语句！</span></span><br><span class="line">			Statement Statement = conn.createStatement();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 要执行的SQL语句</span></span><br><span class="line">			String sql = <span class="string">"select * from mail"</span>;</span><br><span class="line">			<span class="comment">// ResultSet类，用来存放获取的结果集！</span></span><br><span class="line">			ResultSet rs = Statement.executeQuery(sql);</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"执行结果如下所示:"</span>);</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"邮箱"</span> + <span class="string">"\t"</span> + <span class="string">"密码"</span>);</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			<span class="keyword">int</span> id;</span><br><span class="line">			String ads = <span class="keyword">null</span>;</span><br><span class="line">			String pwd = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">				id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">				ads = rs.getString(<span class="string">"address"</span>);</span><br><span class="line">				pwd = rs.getString(<span class="string">"password"</span>);</span><br><span class="line">				<span class="comment">// 输出结果</span></span><br><span class="line">				System.out.println(ads + <span class="string">"\t"</span> + pwd);</span><br><span class="line">			&#125;</span><br><span class="line">			rs.close();</span><br><span class="line">			conn.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// 数据库驱动类异常处理</span></span><br><span class="line">			System.out.println(<span class="string">"数据库驱动加载失败！"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			<span class="comment">// 数据库连接失败异常处理</span></span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">			e2.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"数据库数据获取成功！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="安装navicat"><a href="#安装navicat" class="headerlink" title="安装navicat"></a>安装navicat</h1><p>本身对自带的管理器也不反感，可惜Oracle公司所有产品不支持Windows下的高分辨率屏，对于拥有一块2k屏一块3k屏的我来说太难受了。<br>中文管理界面+连接各种不同的数据库实在是太优秀了。</p>
<p>针对遇到的authentication plugin xxx的问题，解答：<a href="https://blog.csdn.net/u011182575/article/details/80821418" target="_blank" rel="noopener">Navicat Premium 12连接MySQL数据库出现Authentication plugin ‘caching_sha2_password’ cannot be loaded的解决方案</a></p>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/84995633" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84995633</a></p>
]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>JAVA</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>新版OpenGL学习入门（二）——绘制图形</title>
    <url>/2018/12/01/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<p>教程链接：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好，三角形</a></p>
<p>这一章学的东西超级多，学完也算基本入门啦</p>
<a id="more"></a>
<p>那就从最基础的开始吧</p>
<h1 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h1><p>首先是坐标轴，它是高中数学学的直角坐标系的坐标轴，理解特别简单。</p>
<p>对应的数值需要在-1和1之间，大概类似百分比吧，最后的f代表浮点数。</p>
<p>和顶点对应的是顶点缓冲对象VBO，先是创建一个unsigned int来储存id，然后创建顶点缓冲对象，再是绑定缓冲对象</p>
<p>最后把顶点数据缓冲进去</p>
<p>这里glBufferData最后一个参数是显卡管理给定数据的模式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_STATIC_DRAW</td>
<td style="text-align:left">数据几乎不会改变</td>
</tr>
<tr>
<td style="text-align:left">GL_DYNAMIC_DRAW</td>
<td style="text-align:left">数据会改变很多</td>
</tr>
<tr>
<td style="text-align:left">GL_STREAM_DRAW</td>
<td style="text-align:left">数据每次绘制都会改变</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点坐标x,y,z，需要在-1到1之间，标准数学坐标轴</span></span><br><span class="line"><span class="comment">//如果是2d的话z变为0</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;                      <span class="comment">//VBO顶点缓冲对象的id</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把新建的缓冲绑定到GL_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br></pre></td></tr></table></figure>
<h1 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h1><p>着色器相关的在后面有详细介绍，这里主要是为了能够编译使用</p>
<h2 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><h3 id="着色器代码"><a href="#着色器代码" class="headerlink" title="着色器代码"></a>着色器代码</h3><p>这是一个非常基础的GLSL顶点着色器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在着色器的使用过程中，一般是另创建文档来使用的，因此在这边为了简单使用，用字符串记录</p>
<p><strong>注意</strong>这个是写在main函数之前的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GLSL顶点着色器，一般来说着色器会写在其它页面</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span>      <span class="comment">//GLSL版本，与OpenGL版本对应</span></span><br><span class="line">	<span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span>  <span class="comment">//可以把vec3的数据看作vec4构造器的参数，最后一个是透视除法（？）</span></span><br><span class="line">	<span class="string">"&#125;\0"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="编译顶点着色器"><a href="#编译顶点着色器" class="headerlink" title="编译顶点着色器"></a>编译顶点着色器</h3><p>这个和VBO类似，先是着色器id，然后创建着色器，再编译着色器，最后判断是否成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译着色器</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;                                       <span class="comment">//创建顶点着色器对象</span></span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);                 <span class="comment">//创建顶点着色器</span></span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);      <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">//判断编译是否成功</span></span><br><span class="line"><span class="keyword">int</span> sucess;                                                      <span class="comment">//获取着色器编译是否成功的参数</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];                                               <span class="comment">//如果编译失败获取失败的内容</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;sucess);         <span class="comment">//检查编译是否成功</span></span><br><span class="line"><span class="keyword">if</span> (!sucess)                                                     <span class="comment">//如果编译失败，输出信息</span></span><br><span class="line">&#123;</span><br><span class="line">	glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPLIATION_FILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>这个几乎和顶点着色器一模一样</p>
<h3 id="着色器代码-1"><a href="#着色器代码-1" class="headerlink" title="着色器代码"></a>着色器代码</h3><p>源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写在同一个.cpp下的话</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 片段着色器同上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line">	<span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>        <span class="comment">//RGB色，最后一个alpha透明度</span></span><br><span class="line">	<span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="编译片段着色器"><a href="#编译片段着色器" class="headerlink" title="编译片段着色器"></a>编译片段着色器</h3><p>这里比上面少了两行报错内容的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译片段着色器，原理基本同上</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;                                     <span class="comment">//创建片段着色器对象</span></span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);             <span class="comment">//创建顶点着色器</span></span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);  <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"><span class="comment">//判断编译是否成功</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)                                                    <span class="comment">//判断编译是否成功</span></span><br><span class="line">&#123;</span><br><span class="line">	glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>着色器程序是类似加载顶点着色器和片段着色器,代码一如既往的相似</p>
<p>顺便最后因为着色器程序全部get啦，那么顶点着色器和片段着色器就不需要留着数据了</p>
<p>其实从某种意义上感觉片段着色器和顶点着色器对于着色器程序做的是一个封装处理，这样易于管理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 着色器程序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;                                      <span class="comment">//创建着色器程序对象</span></span><br><span class="line">shaderProgram = glCreateProgram();                               <span class="comment">//创建着色器程序</span></span><br><span class="line">glAttachShader(shaderProgram, vertexShader);                     <span class="comment">//把顶点着色器附加到着色器程序</span></span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);                   <span class="comment">//把片段着色器附加到着色器程序</span></span><br><span class="line">glLinkProgram(shaderProgram);                                    <span class="comment">//对附加的着色器链接到着色器程序</span></span><br><span class="line"><span class="comment">// 检查链接是否成功</span></span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">	glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除不需要的着色器</span></span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>最后如果要使用着色器的话，需要再while循环函数里写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br></pre></td></tr></table></figure>
<h1 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h1><p>它主要是告诉编译器如何解析顶点一类的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line"><span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br></pre></td></tr></table></figure>
<h1 id="顶点数组对象（VAO）"><a href="#顶点数组对象（VAO）" class="headerlink" title="顶点数组对象（VAO）"></a>顶点数组对象（VAO）</h1><p>VAO是用来记录顶点属性的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure>
<p>源代码有把VAO和VBO合在一起，所以来一个合起来的版本吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO;                 <span class="comment">//VAO顶点数组对象，VBO顶点缓冲对象的id</span></span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);            <span class="comment">//生成顶点数组对象，给VAO这个id</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);                <span class="comment">//绑定VAO</span></span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把新建的缓冲绑定到GL_ARRAY_BUFFER</span></span><br><span class="line"><span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line"><span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br></pre></td></tr></table></figure>
<h1 id="索引缓冲对象（EBO）"><a href="#索引缓冲对象（EBO）" class="headerlink" title="索引缓冲对象（EBO）"></a>索引缓冲对象（EBO）</h1><p>EBO又名IBO，可以设置顶点如何生成三角形</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>又是整合版的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO, EBO;            <span class="comment">//VAO顶点数组对象，VBO顶点缓冲对象,EBO索引缓冲对象</span></span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);            <span class="comment">//生成顶点数组对象，给VAO这个id</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);                 <span class="comment">//生成索引缓冲对象，给EBO这个id。类型为GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);                <span class="comment">//绑定VAO</span></span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把VBO绑定到缓冲区GL_ARRAY_BUFFER</span></span><br><span class="line"><span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);     <span class="comment">//把EBO绑定到缓冲区GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class="comment">//设置缓冲区类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line"><span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑防止意外更改</span></span><br><span class="line"><span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line"><span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h1 id="生成图形"><a href="#生成图形" class="headerlink" title="生成图形"></a>生成图形</h1><p>最后只要在while里面运行一下就好啦</p>
<h2 id="生成三角形"><a href="#生成三角形" class="headerlink" title="生成三角形"></a>生成三角形</h2><p>这里是用glDrawArrays运行的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br><span class="line">glBindVertexArray(VAO);                  <span class="comment">//每次需要重新绑定一下VAO</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);        <span class="comment">//设置绘制三角形，有3个顶点</span></span><br></pre></td></tr></table></figure>
<h2 id="生成矩形"><a href="#生成矩形" class="headerlink" title="生成矩形"></a>生成矩形</h2><p>生成矩形需要通过两个三角形来绘制</p>
<p>OpenGL这里给人的感觉好蠢。。为什么不能直接生成矩形，想哭。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br><span class="line">glBindVertexArray(VAO);                  <span class="comment">//每次需要重新绑定一下VAO</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h1 id="代码总汇"><a href="#代码总汇" class="headerlink" title="代码总汇"></a>代码总汇</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;      <span class="comment">//窗口回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;  <span class="comment">//输入控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings 初始化设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;     <span class="comment">//初始宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;    <span class="comment">//初始高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GLSL顶点着色器，一般来说着色器会写在其它页面</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span>      <span class="comment">//GLSL版本，与OpenGL版本对应</span></span><br><span class="line">	<span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span>  <span class="comment">//可以把vec3的数据看作vec4构造器的参数，最后一个是透视除法（？）</span></span><br><span class="line">	<span class="string">"&#125;\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器同上，这个是管理颜色的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line">	<span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line">	<span class="string">"void main()\n"</span></span><br><span class="line">	<span class="string">"&#123;\n"</span></span><br><span class="line">	<span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.8f, 1.0f);\n"</span>        <span class="comment">//RGB色，最后一个alpha透明度</span></span><br><span class="line">	<span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// glfw: initialize and configure   不需要做任何改动</span></span><br><span class="line">	glfwInit();                                             <span class="comment">//初始化GLFW</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);          <span class="comment">//主版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);          <span class="comment">//次版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);   <span class="comment">//核心模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    <span class="comment">// 对于OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw 窗口对象   不需要改动</span></span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">//窗口：宽、高、名称。</span></span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)    <span class="comment">//确保正确创建窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);                                       <span class="comment">//设置窗口上下文为当前线程</span></span><br><span class="line">	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    <span class="comment">//告诉glfw窗口大小会根据改变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glad: load all OpenGL function pointers  加载系统相关的OpenGL函数指针地址的函数   不需要改动</span></span><br><span class="line">	<span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译顶点着色器</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;                                       <span class="comment">//创建顶点着色器对象</span></span><br><span class="line">	vertexShader = glCreateShader(GL_VERTEX_SHADER);                 <span class="comment">//创建顶点着色器</span></span><br><span class="line">	glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);      <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">	glCompileShader(vertexShader);</span><br><span class="line">	<span class="comment">// 判断编译是否成功</span></span><br><span class="line">	<span class="keyword">int</span> success;                                                     <span class="comment">//获取着色器编译是否成功的参数</span></span><br><span class="line">	<span class="keyword">char</span> infoLog[<span class="number">512</span>];                                               <span class="comment">//如果编译失败获取失败的内容</span></span><br><span class="line">	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);        <span class="comment">//检查编译是否成功</span></span><br><span class="line">	<span class="keyword">if</span> (!success)                                                    <span class="comment">//如果编译失败，输出信息</span></span><br><span class="line">	&#123;</span><br><span class="line">		glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPLIATION_FILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译片段着色器，原理基本同上</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;                                     <span class="comment">//创建片段着色器对象</span></span><br><span class="line">	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);             <span class="comment">//创建顶点着色器</span></span><br><span class="line">	glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);  <span class="comment">//要编译的着色器，传递的源码字符串数量，顶点着色器真正的源码，（未知）</span></span><br><span class="line">	glCompileShader(fragmentShader);</span><br><span class="line">	<span class="comment">// 判断编译是否成功</span></span><br><span class="line">	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success)                                                    <span class="comment">//判断编译是否成功</span></span><br><span class="line">	&#123;</span><br><span class="line">		glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 着色器程序</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;                                      <span class="comment">//创建着色器程序对象</span></span><br><span class="line">	shaderProgram = glCreateProgram();                               <span class="comment">//创建着色器程序</span></span><br><span class="line">	glAttachShader(shaderProgram, vertexShader);                     <span class="comment">//把顶点着色器附加到着色器程序</span></span><br><span class="line">	glAttachShader(shaderProgram, fragmentShader);                   <span class="comment">//把片段着色器附加到着色器程序</span></span><br><span class="line">	glLinkProgram(shaderProgram);                                    <span class="comment">//对附加的着色器链接到着色器程序</span></span><br><span class="line">	<span class="comment">// 检查链接是否成功</span></span><br><span class="line">	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">		glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除不需要的着色器</span></span><br><span class="line">	glDeleteShader(vertexShader);</span><br><span class="line">	glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//顶点坐标x,y,z，需要在-1到1之间，标准数学坐标轴</span></span><br><span class="line">	<span class="comment">//如果是2d的话z变为0</span></span><br><span class="line">	<span class="keyword">float</span> vertices[] = &#123;                   <span class="comment">//储存的点是x,y,z;x,y,z这样循环的</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;             <span class="comment">//设置顶点练成三角形</span></span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,</span><br><span class="line">		<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO, EBO;            <span class="comment">//VAO顶点数组对象，VBO顶点缓冲对象,EBO索引缓冲对象</span></span><br><span class="line">	glGenVertexArrays(<span class="number">1</span>, &amp;VAO);            <span class="comment">//生成顶点数组对象，给VAO这个id</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);                 <span class="comment">//生成顶点缓冲对象，给VBO这个id。类型为GL_ARRAY_BUFFER</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;EBO);                 <span class="comment">//生成索引缓冲对象，给EBO这个id。类型为GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line"></span><br><span class="line">	glBindVertexArray(VAO);                <span class="comment">//绑定VAO</span></span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);    <span class="comment">//把VBO绑定到缓冲区GL_ARRAY_BUFFER</span></span><br><span class="line">	<span class="comment">//把顶点数据复制到缓冲的内存中</span></span><br><span class="line">	<span class="comment">//显卡管理给定数据的模式：GL_STATIC_DRAW数据几乎不会改变，GL_DYNAMIC_DRAW数据会改变很多，GL_STREAM_DRAW数据每次绘制都会改变</span></span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);    <span class="comment">//顶点缓冲对象，传送数据大小，发送的实际数据，显卡管理给定数据的模式</span></span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);     <span class="comment">//把EBO绑定到缓冲区GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line">	glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class="comment">//设置缓冲区类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置顶点属性（对应顶点着色器中layout(location=0))，顶点属性大小(vec3对应大小为3)，指定数据的类型</span></span><br><span class="line">	<span class="comment">//是否被标准化（？和是否有符号有关），步长（每个顶点的间隔），强制类型转换+起始点的偏移量</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//用来解析顶点</span></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);        <span class="comment">//以顶点属性位置值为参数，启用顶点属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//解绑防止意外更改</span></span><br><span class="line">	<span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line">	<span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span></span><br><span class="line">	glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// render loop  渲染循环，这样可以保持一直运行</span></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输入</span></span><br><span class="line">		processInput(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//渲染指令</span></span><br><span class="line">		glClearColor(<span class="number">0.1f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);    <span class="comment">//设置清空屏幕所用的颜色，每次循环重新渲染，因此需要清空，也因此这是屏幕的背景色。RGB色</span></span><br><span class="line">		glClear(GL_COLOR_BUFFER_BIT);            <span class="comment">//清楚颜色缓冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		glUseProgram(shaderProgram);             <span class="comment">//激活程序对象</span></span><br><span class="line">		glBindVertexArray(VAO);                  <span class="comment">//每次需要重新绑定一下VAO</span></span><br><span class="line">		glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);    <span class="comment">//6个顶点</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查并调用事件、交换缓冲</span></span><br><span class="line">		glfwSwapBuffers(window);      <span class="comment">//交换颜色缓冲</span></span><br><span class="line">		glfwPollEvents();             <span class="comment">//检查事件触发</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">	glfwTerminate();     <span class="comment">//终止glfw</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)    <span class="comment">//判断是否按下Esc</span></span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);               <span class="comment">//如果时Esc，那么glfw需要关闭窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes 根据窗口大小改变显示大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// make sure the viewport matches the new window dimensions; note that width and</span></span><br><span class="line">	<span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);    <span class="comment">//窗口左下角的坐标x、y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搬运自CSDN：<a href="https://blog.csdn.net/yueyue200830/article/details/84675512" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84675512</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>新版OpenGL学习入门（一）——初始化窗口</title>
    <url>/2018/12/01/%E6%96%B0%E7%89%88OpenGL%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>主要用来记录一下学习代码，每次新建一个项目还要配置太麻烦啦</p>
<p>配置网址：<a href="https://blog.csdn.net/qq_19003345/article/details/76098781" target="_blank" rel="noopener">https://blog.csdn.net/qq_19003345/article/details/76098781</a> </p>
<p>学习的是可编辑管线，不过顺便也配置了一下旧版本的，这样可以偶尔运行一下别人的代码</p>
<a id="more"></a>
<p><em>题外话：新版OpenGL比较少，一不小心就找到旧的了。而且和旧版相比，新版需要理解的东西太多了</em></p>
<p>学习网址（这是中文翻译网站）：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/</a></p>
<p>这个代码全部都是原来教程上的，不过加了一点<strong>自己的备注</strong>。建议跟着教程阅读，直接看代码很累。</p>
<blockquote>
<p>Update：如果只是为了写出东西的话，这一块初始化内容完全可以不要去管它</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;      <span class="comment">//窗口回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;  <span class="comment">//输入控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings 初始化设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;     <span class="comment">//初始宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;    <span class="comment">//初始高度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// glfw: initialize and configure   不需要做任何改动</span></span><br><span class="line">	glfwInit();                                             <span class="comment">//初始化GLFW</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);          <span class="comment">//主版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);          <span class="comment">//次版本号为3</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);   <span class="comment">//核心模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    <span class="comment">// 对于OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw 窗口对象   不需要改动</span></span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">//窗口：宽、高、名称。</span></span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)    <span class="comment">//确保正确创建窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);                                       <span class="comment">//设置窗口上下文为当前线程</span></span><br><span class="line">	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    <span class="comment">//告诉glfw窗口大小会根据改变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glad: load all OpenGL function pointers  加载系统相关的OpenGL函数指针地址的函数   不需要改动</span></span><br><span class="line">	<span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// render loop  渲染循环，这样可以保持一直运行</span></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 输入</span></span><br><span class="line">		processInput(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//渲染指令</span></span><br><span class="line">		glClearColor(<span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);    <span class="comment">//设置清空屏幕所用的颜色，每次循环重新渲染，因此需要清空，也因此这是屏幕的背景色。RGB色</span></span><br><span class="line">		glClear(GL_COLOR_BUFFER_BIT);            <span class="comment">//清楚颜色缓冲</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查并调用事件、交换缓冲</span></span><br><span class="line">		glfwSwapBuffers(window);      <span class="comment">//交换颜色缓冲</span></span><br><span class="line">		glfwPollEvents();             <span class="comment">//检查事件触发</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">	glfwTerminate();     <span class="comment">//终止glfw</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)    <span class="comment">//判断是否按下Esc</span></span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);               <span class="comment">//如果时Esc，那么glfw需要关闭窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes 根据窗口大小改变显示大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// make sure the viewport matches the new window dimensions; note that width and</span></span><br><span class="line">	<span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);    <span class="comment">//窗口左下角的坐标x、y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从CSDN搬过来的，原文链接：<a href="https://blog.csdn.net/yueyue200830/article/details/84672369" target="_blank" rel="noopener">https://blog.csdn.net/yueyue200830/article/details/84672369</a></p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
</search>
